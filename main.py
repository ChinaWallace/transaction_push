# -*- coding: utf-8 -*-
"""
Python Trading Analysis Tool - ‰∏ªÁ®ãÂ∫èÂÖ•Âè£
Main entry point for the Python Trading Analysis Tool
"""

import uvicorn
import asyncio
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from app.core.config import get_settings
from app.core.logging import get_logger
from datetime import datetime

# ÂÆâÂÖ®ÂØºÂÖ•Êï∞ÊçÆÂ∫ìÊ®°Âùó
try:
    from app.core.database import create_tables, db_manager
    from app.utils.db_monitor import get_db_monitor
    DATABASE_AVAILABLE = True
    logger = get_logger(__name__)
    logger.debug("‚úÖ Database module imported successfully")
except Exception as e:
    logger = get_logger(__name__)
    logger.warning(f"‚ö†Ô∏è Database module import failed: {e}")
    logger.info("üí° Application will run in memory-only mode")
    DATABASE_AVAILABLE = False
    db_manager = None
    create_tables = None
    get_db_monitor = None

# ÂØºÂÖ•ÊâÄÊúâÊ®°Âûã‰ª•Á°Æ‰øùË°®ÂÆö‰πâË¢´Ê≥®ÂÜå
import app.models  # Ëøô‰ºöÂØºÂÖ•ÊâÄÊúâÊ®°ÂûãÂÆö‰πâ

# ÂØºÂÖ•Ê†∏ÂøÉÊï¥ÂêàAPIË∑ØÁî± - ‰ºòÂÖàÁ∫ßÊúÄÈ´ò
from app.api.core_trading import router as core_trading_router

# ÂØºÂÖ•ÂéüÊúâAPIË∑ØÁî± - ‰øùÊåÅÂÖºÂÆπÊÄß
from app.api import (
    trend_router, monitor_router, notification_router,
    tradingview_router, strategy_router, ml_enhanced_router,
    backtest_router
)
from app.api.news import router as news_router
from app.api.kronos import router as kronos_router
from app.api.kronos_integrated import router as kronos_integrated_router
from app.api.funding_monitor import router as funding_monitor_router
from app.api.kronos_market_opportunities import router as kronos_market_opportunities_router
from app.api.kronos_advanced_opportunities import router as kronos_advanced_opportunities_router
from app.api.notification_stats import router as notification_stats_router
from app.api.database import router as database_router
from app.api.http_pool import router as http_pool_router
from app.api.trading_pairs import router as trading_pairs_router
from app.api.unified_data import router as unified_data_router
from app.api.ml_config import router as ml_config_router
from app.services.scheduler_service import SchedulerService
from app.services.ml_enhanced_service import MLEnhancedService
from app.services.negative_funding_monitor_service import NegativeFundingMonitorService

# Ëé∑ÂèñÈÖçÁΩÆÂíåÊó•Âøó
settings = get_settings()
logger = get_logger(__name__)

async def perform_startup_trading_analysis():
    """ÂêØÂä®Êó∂ÊâßË°åÂÆåÊï¥ÁöÑ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÂíåÊé®ÈÄÅ - ‰ΩøÁî®Kronos+‰º†Áªü+MLÁöÑÁªºÂêàÂÜ≥Á≠ñÊúçÂä°"""
    try:
        logger.info("üéØ ÂºÄÂßãÂêØÂä®ÂÆåÊï¥‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûê (Kronos+‰º†Áªü+MLÁªºÂêà)...")
        
        # ‰ΩøÁî®Â¢ûÂº∫ÁöÑÊ†∏ÂøÉ‰∫§ÊòìÊúçÂä°ÔºåÈõÜÊàêKronosÂàÜÊûê
        from app.services.core_trading_service import get_core_trading_service, AnalysisType
        from app.services.core_notification_service import get_core_notification_service
        
        core_trading_service = await get_core_trading_service()
        notification_service = await get_core_notification_service()
        
        # ‰∏ªË¶ÅÂàÜÊûêÁöÑ‰∫§ÊòìÂØπ
        major_symbols = ["BTC-USDT-SWAP", "ETH-USDT-SWAP", "SOL-USDT-SWAP", "DOGE-USDT-SWAP", "XRP-USDT-SWAP"]
        
        # ÊâßË°åÂÆåÊï¥ÁöÑ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûê
        analysis_results = []
        notifications_sent = 0
        
        for symbol in major_symbols:
            try:
                logger.info(f"üîç ÁªºÂêàÂàÜÊûê {symbol} (Kronos+ÊäÄÊúØ+ML)...")
                
                # ‰ΩøÁî®ÈõÜÊàêÂàÜÊûê - ÂåÖÂê´Kronos„ÄÅ‰º†ÁªüÊäÄÊúØÂàÜÊûê„ÄÅMLÈ¢ÑÊµã
                trading_signal = await core_trading_service.analyze_symbol(
                    symbol=symbol,
                    analysis_type=AnalysisType.INTEGRATED,  # ‰ΩøÁî®ÁªºÂêàÂàÜÊûê
                    force_update=True
                )
                
                if not trading_signal:
                    logger.warning(f"‚ö†Ô∏è {symbol} ÂàÜÊûêÂ§±Ë¥•ÔºåË∑≥Ëøá")
                    continue
                
                # Êó•ÂÜÖÁü≠Á∫ø‰∫§Êòì‰ºòÂåñÔºöÂ§ßÂπÖÈôç‰ΩéÊé®ÈÄÅÈòàÂÄºÔºå‰∏ìÊ≥®5-15ÂàÜÈíüÁ∫ßÂà´‰ø°Âè∑
                # Ê£ÄÊü•ÊòØÂê¶ÊòØÁü≠Á∫ø‰ø°Âè∑ (ÈùûHOLD‰∏îÁΩÆ‰ø°Â∫¶>35% ÈÄÇÂêàÊó•ÂÜÖÁü≠Á∫ø‰∫§Êòì)
                if (trading_signal.final_action.upper() not in ['HOLD', 'ÊåÅÊúâ', 'ËßÇÊúõ', 'Á≠âÂæÖ'] and 
                    trading_signal.final_confidence > 0.35):
                    
                    # ËΩ¨Êç¢ÁΩÆ‰ø°Â∫¶Ê†ºÂºè
                    confidence_percent = trading_signal.final_confidence * 100 if trading_signal.final_confidence <= 1 else trading_signal.final_confidence
                    
                    analysis_results.append({
                        "symbol": symbol,
                        "action": trading_signal.final_action,
                        "confidence": confidence_percent,
                        "signal_strength": trading_signal.signal_strength.value if hasattr(trading_signal.signal_strength, 'value') else str(trading_signal.signal_strength),
                        "reasoning": trading_signal.reasoning,
                        "kronos_confidence": trading_signal.confidence_breakdown.get('kronos', 0) * 100,
                        "technical_confidence": trading_signal.confidence_breakdown.get('technical', 0) * 100,
                        "ml_confidence": trading_signal.confidence_breakdown.get('ml', 0) * 100,
                        "trading_signal": trading_signal
                    })
                    
                    # ‰ΩøÁî®Ê†∏ÂøÉ‰∫§ÊòìÊúçÂä°ÁöÑÊé®ÈÄÅÊñπÊ≥ï
                    try:
                        # Â¢ûÂº∫ÈÄöÁü•ÂÜÖÂÆπÔºåÂåÖÂê´ÊäÄÊúØÊåáÊ†áËØ¶ÊÉÖ
                        if hasattr(trading_signal, 'technical_result') and trading_signal.technical_result:
                            # ‰ªéÊäÄÊúØÂàÜÊûêÁªìÊûú‰∏≠ÊèêÂèñÊåáÊ†á‰ø°ÊÅØ
                            recommendation = trading_signal.technical_result.get('recommendation')
                            if recommendation and hasattr(recommendation, 'reasoning'):
                                # Â∞ÜÊäÄÊúØÊåáÊ†á‰ø°ÊÅØÊ∑ªÂä†Âà∞‰ø°Âè∑‰∏≠
                                trading_signal.technical_indicators = getattr(trading_signal, 'technical_indicators', {})
                                trading_signal.technical_indicators['analysis_details'] = recommendation.reasoning
                        
                        success = await core_trading_service.send_trading_signal_notification(trading_signal)
                        if success:
                            notifications_sent += 1
                            logger.info(f"‚úÖ ÂèëÈÄÅ {symbol} ÁªºÂêà‰∫§Êòì‰ø°Âè∑ÈÄöÁü•ÊàêÂäü")
                        else:
                            logger.warning(f"‚ùå ÂèëÈÄÅ {symbol} ÁªºÂêà‰∫§Êòì‰ø°Âè∑ÈÄöÁü•Â§±Ë¥•")
                        
                    except Exception as e:
                        logger.warning(f"ÂèëÈÄÅ {symbol} ‰∫§Êòì‰ø°Âè∑ÈÄöÁü•Â§±Ë¥•: {e}")
                
                else:
                    confidence_percent = trading_signal.final_confidence * 100 if trading_signal.final_confidence <= 1 else trading_signal.final_confidence
                    
                    # ËØ¶ÁªÜÊâìÂç∞ÊâÄÊúâÂàÜÊûêÁªìÊûúÔºåÂåÖÊã¨‰∏çÁ¨¶ÂêàÊé®ÈÄÅÊù°‰ª∂ÁöÑ
                    symbol_name = symbol.replace('-USDT-SWAP', '')
                    logger.info(f"üìä {symbol_name}: {trading_signal.final_action} (ÁªºÂêàÁΩÆ‰ø°Â∫¶: {confidence_percent:.1f}%) - ‰∏çÁ¨¶ÂêàÊé®ÈÄÅÊù°‰ª∂")
                    
                    # ÊâìÂç∞ÂêÑÊ®°ÂùóÁöÑËØ¶ÁªÜÂàÜÊûêÁªìÊûú
                    kronos_conf = trading_signal.confidence_breakdown.get('kronos', 0) * 100
                    technical_conf = trading_signal.confidence_breakdown.get('technical', 0) * 100
                    ml_conf = trading_signal.confidence_breakdown.get('ml', 0) * 100
                    
                    logger.info(f"   üîç ËØ¶ÁªÜÂàÜÊûê: ü§ñ Kronos: {kronos_conf:.1f}% | üìä ÊäÄÊúØ: {technical_conf:.1f}% | üß† ML: {ml_conf:.1f}%")
                    
                    # ÊâìÂç∞ÂÜ≥Á≠ñ‰æùÊçÆ
                    if hasattr(trading_signal, 'reasoning') and trading_signal.reasoning:
                        logger.info(f"   üí≠ ÂÜ≥Á≠ñ‰æùÊçÆ: {trading_signal.reasoning}")
                    
                    # ÊâìÂç∞ÂÖ≥ÈîÆÂõ†Á¥†
                    if hasattr(trading_signal, 'key_factors') and trading_signal.key_factors:
                        factors = trading_signal.key_factors[:3]
                        logger.info(f"   üìà ÂÖ≥ÈîÆÂõ†Á¥†: {', '.join(factors)}")
                    
                    # ÊâìÂç∞KronosÈ¢ÑÊµãËØ¶ÊÉÖÔºàÂ¶ÇÊûúÊúâÔºâ
                    if hasattr(trading_signal, 'kronos_result') and trading_signal.kronos_result:
                        kronos_result = trading_signal.kronos_result
                        if hasattr(kronos_result, 'kronos_prediction') and kronos_result.kronos_prediction:
                            pred = kronos_result.kronos_prediction
                            price_change = pred.price_change_pct * 100
                            logger.info(f"   ü§ñ KronosÈ¢ÑÊµã: ‰ª∑Ê†ºÂèòÂåñ {price_change:+.2f}%, ÁΩÆ‰ø°Â∫¶ {pred.confidence:.2f}")
                    
                    # ÊâìÂç∞ÊäÄÊúØÂàÜÊûêËØ¶ÊÉÖÔºàÂ¶ÇÊûúÊúâÔºâ
                    if hasattr(trading_signal, 'technical_result') and trading_signal.technical_result:
                        tech_result = trading_signal.technical_result
                        tech_action = tech_result.get('action', 'Unknown')
                        tech_confidence = tech_result.get('confidence', 0) * 100
                        logger.info(f"   üìä ÊäÄÊúØÂàÜÊûê: {tech_action} (ÁΩÆ‰ø°Â∫¶: {tech_confidence:.1f}%)")
                    
                    logger.info(f"   ‚ö†Ô∏è Êú™Êé®ÈÄÅÂéüÂõ†: ÁΩÆ‰ø°Â∫¶{confidence_percent:.1f}% < 35% Êàñ Ë°åÂä®‰∏∫ËßÇÊúõÁ±ªÂûã (Êó•ÂÜÖÁü≠Á∫øÈòàÂÄº)")
                    
            except Exception as e:
                logger.warning(f"‚ùå ÂàÜÊûê {symbol} Â§±Ë¥•: {e}")
                continue
        
        # ÊûÑÂª∫ËøîÂõûÁªìÊûú
        startup_results = {
            "status": "success",
            "total_analyzed": len(major_symbols),
            "successful_analyses": len(analysis_results),
            "notifications_sent": notifications_sent,
            "strong_signals": analysis_results,
            "analysis_method": "core_trading_service_with_kronos_integration"
        }
        
        # ËÆ∞ÂΩïÂàÜÊûêÁªìÊûú
        logger.info(f"‚úÖ ÂêØÂä®ÂÆåÊï¥‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÂÆåÊàê (Kronos+ÊäÄÊúØ+ML):")
        logger.info(f"   üìä ÂàÜÊûê‰∫§ÊòìÂØπ: {len(major_symbols)} ‰∏™")
        logger.info(f"   üéØ ÂèëÁé∞Âº∫‰ø°Âè∑: {len(analysis_results)} ‰∏™")
        logger.info(f"   üì¢ ÈÄöÁü•ÂèëÈÄÅ: {notifications_sent} Êù°")
        logger.info(f"   üîß ÂàÜÊûêÊñπÊ≥ï: Kronos AI + Â¢ûÂº∫ÊäÄÊúØÂàÜÊûê + Êú∫Âô®Â≠¶‰π†")
        
        # ËÆ∞ÂΩïÂº∫‰ø°Âè∑ËØ¶ÊÉÖ
        for i, signal in enumerate(analysis_results[:3], 1):
            symbol = signal["symbol"].replace('-USDT-SWAP', '')
            action = signal["action"]
            confidence = signal["confidence"]
            signal_strength = signal["signal_strength"]
            kronos_conf = signal.get('kronos_confidence', 0)
            technical_conf = signal.get('technical_confidence', 0)
            ml_conf = signal.get('ml_confidence', 0)
            
            logger.info(f"   {i}. üéØ {symbol}: {action} (ÁªºÂêà: {confidence:.1f}%)")
            logger.info(f"      ü§ñ Kronos: {kronos_conf:.1f}% | üìä ÊäÄÊúØ: {technical_conf:.1f}% | üß† ML: {ml_conf:.1f}%")
            logger.info(f"      üî• ‰ø°Âè∑Âº∫Â∫¶: {signal_strength}")
            
            # ÊòæÁ§∫ÊäÄÊúØÊåáÊ†á‰∫ÆÁÇπ
            if len(signal.get('key_factors', [])) > 0:
                factors = signal['key_factors'][:3]
                logger.info(f"      üìà ÂÖ≥ÈîÆÂõ†Á¥†: {', '.join(factors)}")
        
        return startup_results
        
    except Exception as e:
        logger.error(f"‚ùå ÂêØÂä®ÂÆåÊï¥‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÂ§±Ë¥•: {e}")
        return {"status": "error", "error": str(e)}

# Â∑≤ÁßªÈô§ perform_startup_kronos_market_scan() ÂáΩÊï∞
# ÂéüÂõ†: ‰∏é perform_startup_trading_analysis() ÂäüËÉΩÈáçÂ§ç
# Ê†∏ÂøÉ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÂ∑≤ÁªèÂåÖÂê´‰∫ÜKronosÂàÜÊûêÂíå‰ø°Âè∑Êé®ÈÄÅÂäüËÉΩ

async def send_startup_summary_notification(app_state, successful_tasks: int, failed_tasks: int):
    """ÂèëÈÄÅÂêØÂä®ÂÆåÊàêÊëòË¶ÅÈÄöÁü•"""
    try:
        from app.services.core_notification_service import get_core_notification_service
        notification_service = await get_core_notification_service()
        
        # Êî∂ÈõÜÂêÑ‰ªªÂä°ÁªìÊûú
        trading_result = getattr(app_state, 'startup_trading_analysis_results', {})
        funding_result = getattr(app_state, 'startup_funding_analysis_results', {})
        news_result = getattr(app_state, 'startup_news_analysis_results', {})
        kronos_result = getattr(app_state, 'startup_kronos_market_scan_results', {})
        
        # ÊûÑÂª∫ÊëòË¶ÅÊ∂àÊÅØ
        message = f"üöÄ **‰∫§ÊòìÂàÜÊûêÂ∑•ÂÖ∑ÂêØÂä®ÂÆåÊàê**\n\n"
        message += f"üìä ‰ªªÂä°ÊâßË°å: {successful_tasks} ÊàêÂäü, {failed_tasks} Â§±Ë¥•\n\n"
        
        # ÂÆåÊï¥‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÁªìÊûú
        if trading_result.get("status") == "success":
            strong_signals = len(trading_result.get("strong_signals", []))
            notifications = trading_result.get("notifications_sent", 0)
            message += f"üéØ ÂÆåÊï¥‰∫§ÊòìÂàÜÊûê: {strong_signals} ‰∏™Âº∫‰ø°Âè∑, {notifications} Êù°ÈÄöÁü•\n"
        
        # Ë¥üË¥πÁéáÂàÜÊûêÁªìÊûú
        if funding_result.get("status") == "success":
            opportunities = funding_result.get("opportunities_count", 0)
            message += f"üí∞ Ë¥üË¥πÁéáÊú∫‰ºö: {opportunities} ‰∏™Â•óÂà©Êú∫‰ºö\n"
        
        # Êñ∞ÈóªÂàÜÊûêÁªìÊûú - ÊöÇÊó∂Ê≥®ÈáäÊéâ
        # if news_result.get("status") == "success":
        #     news_notifications = news_result.get("notifications_sent", 0)
        #     message += f"üì∞ Êñ∞ÈóªÂàÜÊûê: {news_notifications} Êù°ÈáçË¶ÅÊñ∞Èóª\n"
        # elif news_result.get("status") == "disabled":
        #     message += f"üì¥ Êñ∞ÈóªÂàÜÊûê: Â∑≤Á¶ÅÁî®\n"
        
        # KronosÂ∏ÇÂú∫Êâ´Êèè - Â∑≤Êï¥ÂêàÂà∞Ê†∏ÂøÉ‰∫§ÊòìÂàÜÊûê‰∏≠
        if kronos_result.get("status") == "success":
            kronos_opportunities = kronos_result.get("summary", {}).get("total_strong_opportunities", 0)
            message += f"ü§ñ KronosÊâ´Êèè: {kronos_opportunities} ‰∏™AIÊú∫‰ºö (Â∑≤Êï¥Âêà)\n"
        else:
            message += f"ü§ñ KronosÊâ´Êèè: Â∑≤Êï¥ÂêàÂà∞Ê†∏ÂøÉÂàÜÊûê\n"
        
        message += f"\n‚è∞ ÂêØÂä®Êó∂Èó¥: {datetime.now().strftime('%H:%M:%S')}"
        message += f"\nüîÑ Á≥ªÁªüÂ∑≤Â∞±Áª™ÔºåÂºÄÂßãÁõëÊéßÂ∏ÇÂú∫..."
        
        # Á°ÆÂÆöÈÄöÁü•‰ºòÂÖàÁ∫ß
        total_signals = (
            len(trading_result.get("strong_signals", [])) +
            funding_result.get("opportunities_count", 0) +
            kronos_result.get("summary", {}).get("total_strong_opportunities", 0)
        )
        
        priority = "high" if total_signals > 0 else "medium" if failed_tasks == 0 else "low"
        
        from app.services.core_notification_service import NotificationContent, NotificationType, NotificationPriority
        
        # ËΩ¨Êç¢‰ºòÂÖàÁ∫ßÂ≠óÁ¨¶‰∏≤‰∏∫Êûö‰∏æ
        priority_map = {
            "high": NotificationPriority.HIGH,
            "medium": NotificationPriority.NORMAL,
            "low": NotificationPriority.LOW
        }
        
        content = NotificationContent(
            type=NotificationType.SYSTEM_ALERT,
            priority=priority_map.get(priority, NotificationPriority.NORMAL),
            title=f"üöÄ Á≥ªÁªüÂêØÂä®ÂÆåÊàê ({successful_tasks}/{successful_tasks + failed_tasks})",
            message=message,
            metadata={
                'successful_tasks': successful_tasks,
                'failed_tasks': failed_tasks,
                'total_signals': total_signals
            }
        )
        
        await notification_service.send_notification(content)
        
        logger.info(f"‚úÖ ÂêØÂä®ÊëòË¶ÅÈÄöÁü•Â∑≤ÂèëÈÄÅ (‰ºòÂÖàÁ∫ß: {priority})")
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è ÂèëÈÄÅÂêØÂä®ÊëòË¶ÅÈÄöÁü•Â§±Ë¥•: {e}")

async def perform_startup_funding_analysis():
    """ÂêØÂä®Êó∂ÊâßË°åË¥üË¥πÁéáÂàÜÊûêÂíåÊé®ÈÄÅ"""
    try:
        logger.info("üí∞ ÂºÄÂßãË¥üË¥πÁéáÂêÉÂà©ÊÅØÊú∫‰ºöÂàÜÊûê...")
        
        # ÂàõÂª∫Ë¥üË¥πÁéáÁõëÊéßÊúçÂä°
        funding_monitor = NegativeFundingMonitorService()
        
        # ÊâßË°åÂ¢ûÂº∫ÁâàÁõëÊéßÊ£ÄÊü•ÔºàÂåÖÂê´ËØ¶ÁªÜÁöÑ‰ª∑Ê†ºÈ¢ÑÊµãÂíå‰ªì‰ΩçÂª∫ËÆÆÔºâ
        result = await funding_monitor.run_monitoring_cycle(enable_enhanced_analysis=True)
        
        if result['success']:
            opportunities = result['opportunities']
            logger.info(f"‚úÖ Ë¥üË¥πÁéáÂàÜÊûêÂÆåÊàê: ÂèëÁé∞ {len(opportunities)} ‰∏™ÂêÉÂà©ÊÅØÊú∫‰ºö")
            
            if opportunities:
                # ËÆ∞ÂΩïÊúÄ‰Ω≥Êú∫‰ºö
                best = opportunities[0]
                symbol_name = best['symbol'].replace('-USDT-SWAP', '')
                daily_rate = best['daily_rate_percent']
                daily_income = best['daily_income_10k']
                
                logger.info(f"üéØ ÊúÄ‰Ω≥Êú∫‰ºö: {symbol_name}")
                logger.info(f"   üí∞ Êó•ÂåñÊî∂Áõä: {daily_rate:.3f}%")
                logger.info(f"   üíµ 1‰∏áUÊó•Êî∂Áõä: ${daily_income:.2f}")
                logger.info(f"   üìä ËØÑÂàÜ: {best['score']}/100")
                
                # ËÆ∞ÂΩïÂâç3‰∏™Êú∫‰ºö
                for i, opp in enumerate(opportunities[:3], 1):
                    symbol = opp['symbol'].replace('-USDT-SWAP', '')
                    rate = opp['funding_rate_percent']
                    daily = opp['daily_rate_percent']
                    logger.info(f"   {i}. {symbol}: {rate:.3f}% ‚Üí Êó•Âåñ {daily:.3f}%")
            else:
                logger.info("üìä ÂΩìÂâçÂ∏ÇÂú∫Êó†Ë¥üË¥πÁéáÊú∫‰ºö")
            
            return {
                "status": "success",
                "opportunities_count": len(opportunities),
                "opportunities": opportunities[:5],  # ËøîÂõûÂâç5‰∏™
                "analysis_time": result['analysis_time'],
                "duration": result['duration_seconds']
            }
        else:
            error_msg = result.get('error', 'Êú™Áü•ÈîôËØØ')
            logger.error(f"‚ùå Ë¥üË¥πÁéáÂàÜÊûêÂ§±Ë¥•: {error_msg}")
            return {"status": "error", "error": error_msg}
            
    except Exception as e:
        logger.error(f"‚ùå Ë¥üË¥πÁéáÂàÜÊûêÂºÇÂ∏∏: {e}")
        return {"status": "error", "error": str(e)}

async def perform_startup_news_analysis():
    """ÂêØÂä®Êó∂ÊâßË°åÊñ∞ÈóªÂàÜÊûêÂíåÊé®ÈÄÅ"""
    try:
        logger.info("üì∞ ÂºÄÂßãÂêØÂä®Êñ∞ÈóªÂàÜÊûê...")
        
        from app.services.news_monitor_service import get_news_monitor_service
        
        # Ëé∑ÂèñÊñ∞ÈóªÁõëÊéßÊúçÂä°
        news_monitor = await get_news_monitor_service()
        
        # ÊâßË°å‰∏ÄÊ¨°ÁõëÊéßÂë®Êúü
        result = await news_monitor.run_monitoring_cycle()
        
        if result['status'] == 'success':
            news_count = result.get('news_count', 0)
            analysis_count = result.get('analysis_count', 0)
            notifications_sent = result.get('notifications_sent', 0)
            
            logger.info(f"‚úÖ ÂêØÂä®Êñ∞ÈóªÂàÜÊûêÂÆåÊàê:")
            logger.info(f"   üì∞ Ëé∑ÂèñÊñ∞Èóª: {news_count} Êù°")
            logger.info(f"   üîç ÂàÜÊûêÊñ∞Èóª: {analysis_count} Êù°")
            logger.info(f"   üì¢ ÂèëÈÄÅÈÄöÁü•: {notifications_sent} Êù°")
            
            return {
                "status": "success",
                "news_count": news_count,
                "analysis_count": analysis_count,
                "notifications_sent": notifications_sent,
                "duration": result.get('duration_seconds', 0),
                "message": result.get('message', 'ÂàÜÊûêÂÆåÊàê')
            }
        elif result['status'] == 'disabled':
            logger.info("üì¥ Êñ∞ÈóªÂàÜÊûêÂ∑≤Á¶ÅÁî®")
            return {"status": "disabled", "message": "Êñ∞ÈóªÂàÜÊûêÂ∑≤Á¶ÅÁî®"}
        else:
            error_msg = result.get('message', 'Êú™Áü•ÈîôËØØ')
            logger.error(f"‚ùå ÂêØÂä®Êñ∞ÈóªÂàÜÊûêÂ§±Ë¥•: {error_msg}")
            return {"status": "error", "error": error_msg}
            
    except Exception as e:
        logger.error(f"‚ùå ÂêØÂä®Êñ∞ÈóªÂàÜÊûêÂºÇÂ∏∏: {e}")
        return {"status": "error", "error": str(e)}

async def perform_startup_ml_analysis(ml_service: MLEnhancedService):
    """ÂêØÂä®Êó∂ÊâßË°åMLÂàÜÊûêÂíåÊé®ÈÄÅÔºàÂèØÈÄâÔºâ"""
    try:
        logger.info("ü§ñ ÂºÄÂßãMLÂ¢ûÂº∫ÂàÜÊûê...")
        # MLÈÄöÁü•ÂäüËÉΩÂ∑≤Êï¥ÂêàÂà∞Ê†∏ÂøÉÈÄöÁü•ÊúçÂä°‰∏≠
        from app.services.core_notification_service import get_core_notification_service
        notification_service = await get_core_notification_service()
        
        # ÂØºÂÖ•ÂºÇÂ∏∏Áä∂ÊÄÅÁÆ°ÁêÜÂô®
        from app.services.anomaly_state_manager import anomaly_state_manager
        
        # Ê∏ÖÁêÜËøáÊúüÁöÑÂºÇÂ∏∏ËÆ∞ÂΩï
        anomaly_state_manager.cleanup_old_records(max_age_hours=24)
        
        # ÂàÜÊûêÈÖçÁΩÆ‰∏≠ÁöÑÊâÄÊúâ‰∫§ÊòìÂØπ
        symbols_to_analyze = settings.monitored_symbols
        all_detected_anomalies = []  # Êî∂ÈõÜÊâÄÊúâÂ∏ÅÁßçÊ£ÄÊµãÂà∞ÁöÑÂºÇÂ∏∏
        
        for symbol in symbols_to_analyze:
            try:
                logger.info(f"üîç MLÂàÜÊûê {symbol}...")
                
                # 1. ÊâßË°åÈ¢ÑÊµãÂàÜÊûê
                prediction = await ml_service.predict_signal(symbol)
                logger.info(f"üìä {symbol} MLÈ¢ÑÊµã: {prediction.signal.value} (ÁΩÆ‰ø°Â∫¶: {prediction.confidence:.3f})")
                
                # Èôç‰ΩéMLÈ¢ÑÊµãÊé®ÈÄÅÈó®Êßõ
                if (prediction.signal.value in ['buy', 'sell'] and prediction.confidence > 0.6) or \
                   prediction.signal.value in ['strong_buy', 'strong_sell'] or \
                   (prediction.signal.value == 'hold' and prediction.confidence > 0.8):
                    # ‰ΩøÁî®Ê†∏ÂøÉÈÄöÁü•ÊúçÂä°ÂèëÈÄÅMLÈ¢ÑÊµãÈÄöÁü•
                    await notification_service.send_ml_prediction_notification({
                        'symbol': symbol,
                        'signal': prediction.signal.value,
                        'confidence': prediction.confidence,
                        'timestamp': datetime.now()
                    })
                    logger.info(f"üì¢ Â∑≤ÂèëÈÄÅ {symbol} MLÈ¢ÑÊµãÈÄöÁü•")
                
                # 2. ÊâßË°åÂºÇÂ∏∏Ê£ÄÊµã
                anomalies = await ml_service.detect_anomalies(symbol)
                if anomalies:
                    logger.info(f"‚ö†Ô∏è {symbol} Ê£ÄÊµãÂà∞ {len(anomalies)} ‰∏™ÂºÇÂ∏∏")
                    # ËøáÊª§Âá∫‰∏•ÈáçÁ®ãÂ∫¶Ë∂≥Â§üÁöÑÂºÇÂ∏∏
                    significant_anomalies = [
                        a for a in anomalies 
                        if a.severity > 0.5  # ‰∏•ÈáçÁ®ãÂ∫¶Â§ß‰∫é50%
                    ]
                    
                    if significant_anomalies:
                        all_detected_anomalies.extend(significant_anomalies)
                        logger.info(f"üìä {symbol} ÂèëÁé∞ {len(significant_anomalies)} ‰∏™ÊòæËëóÂºÇÂ∏∏")
                
            except Exception as e:
                logger.warning(f"‚ùå MLÂàÜÊûê {symbol} Â§±Ë¥•: {e}")
                continue
        
        # 3. ‰ΩøÁî®Áä∂ÊÄÅÁÆ°ÁêÜÂô®ËøáÊª§Âá∫ÁúüÊ≠£ÁöÑÊñ∞ÂºÇÂ∏∏
        if all_detected_anomalies:
            new_anomalies = anomaly_state_manager.filter_new_anomalies(all_detected_anomalies)
            
            if new_anomalies:
                # Êåâ‰∏•ÈáçÁ®ãÂ∫¶ÊéíÂ∫èÔºåÂè™Êé®ÈÄÅÊúÄ‰∏•ÈáçÁöÑÂâç5‰∏™
                new_anomalies.sort(key=lambda x: x.severity, reverse=True)
                top_anomalies = new_anomalies[:5]
                
                # ‰ΩøÁî®Ê†∏ÂøÉÈÄöÁü•ÊúçÂä°ÂèëÈÄÅÂºÇÂ∏∏Ë≠¶Êä•
                await notification_service.send_anomaly_notification({
                    'anomalies': [{'symbol': a.symbol, 'severity': a.severity, 'description': str(a)} for a in top_anomalies],
                    'count': len(top_anomalies),
                    'timestamp': datetime.now()
                })
                logger.info(f"üì¢ Â∑≤ÂèëÈÄÅ {len(top_anomalies)} ‰∏™Êñ∞ÂºÇÂ∏∏Ë≠¶Êä•ÔºåÊ∂âÂèäÂ∏ÅÁßç: {list(set(a.symbol for a in top_anomalies))}")
            else:
                logger.info("‚úÖ ÊâÄÊúâÊ£ÄÊµãÂà∞ÁöÑÂºÇÂ∏∏ÈÉΩÂ∑≤ÈÄöÁü•ËøáÔºåË∑≥ËøáÊé®ÈÄÅ")
        else:
            logger.info("‚úÖ Êú™Ê£ÄÊµãÂà∞‰ªª‰ΩïÂºÇÂ∏∏")
        
        # 4. ËæìÂá∫ÂºÇÂ∏∏ÁªüËÆ°‰ø°ÊÅØ
        stats = anomaly_state_manager.get_anomaly_stats()
        if stats:
            logger.info(f"üìä ÂºÇÂ∏∏ÁªüËÆ°: {stats}")
        
        logger.info("‚úÖ MLÂ¢ûÂº∫ÂàÜÊûêÂÆåÊàê")
        
    except Exception as e:
        logger.error(f"‚ùå MLÂ¢ûÂº∫ÂàÜÊûêÂ§±Ë¥•: {e}")

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Â∫îÁî®ÁîüÂëΩÂë®ÊúüÁÆ°ÁêÜ"""
    # ÂêØÂä®Êó∂ÊâßË°å
    logger.info("üöÄ Starting Python Trading Analysis Tool...")
    
    # Â≠òÂÇ®ÈúÄË¶ÅÊ∏ÖÁêÜÁöÑËµÑÊ∫ê
    cleanup_tasks = []
    
    try:
        # Ê£ÄÊü•Êï∞ÊçÆÂ∫ìÊ®°ÂùóÊòØÂê¶ÂèØÁî®
        if not DATABASE_AVAILABLE:
            logger.warning("‚ö†Ô∏è Database module not available - running in memory mode")
            app.state.database_available = False
        else:
            # Â∞ùËØïÂàõÂª∫Êï∞ÊçÆÂ∫ìË°® - ÂÖÅËÆ∏Â§±Ë¥•
            try:
                if create_tables:
                    create_tables()
                    logger.info("‚úÖ Database tables created successfully")
                else:
                    logger.warning("‚ö†Ô∏è create_tables function not available")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Database table creation failed: {e}")
                logger.info("üí° Application will continue without database persistence")
            
            # ÊµãËØïÊï∞ÊçÆÂ∫ìËøûÊé•ÂíåËøûÊé•Ê±† - ÂÖÅËÆ∏Âú®Êï∞ÊçÆÂ∫ì‰∏çÂèØÁî®Êó∂ÁªßÁª≠ËøêË°å
            try:
                # È™åËØÅÊï∞ÊçÆÂ∫ìÁÆ°ÁêÜÂô®ÊòØÂê¶ÂèØÁî®
                logger.debug("üîç ÂºÄÂßãÊï∞ÊçÆÂ∫ìÂÅ•Â∫∑Ê£ÄÊü•...")
                
                # Ê£ÄÊü• db_manager ÊòØÂê¶Â∑≤Ê≠£Á°ÆÂØºÂÖ•ÂíåÂàùÂßãÂåñ
                if db_manager is None:
                    logger.warning("‚ö†Ô∏è Database manager is None - running in memory mode")
                    app.state.database_available = False
                else:
                    logger.debug("‚úÖ Database manager is available, performing health check...")
                    if get_db_monitor:
                        db_monitor = get_db_monitor()
                        
                        if db_manager.health_check():
                            logger.info("‚úÖ Database connection healthy")
                            
                            # ÊòæÁ§∫ËøûÊé•Ê±†Áä∂ÊÄÅ
                            pool_stats = db_monitor.get_pool_stats()
                            logger.info(f"üìä Connection pool stats: {pool_stats}")
                            
                            app.state.database_available = True
                            app.state.db_monitor = db_monitor
                        else:
                            logger.warning("‚ö†Ô∏è Database connection failed - running in memory mode")
                            app.state.database_available = False
                    else:
                        logger.warning("‚ö†Ô∏è get_db_monitor function not available - running in memory mode")
                        app.state.database_available = False
                        
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Database health check failed: {e} - running in memory mode")
                app.state.database_available = False
        
        # ÂêØÂä®Ë∞ÉÂ∫¶Âô®
        scheduler = SchedulerService()
        await scheduler.start()
        logger.info("‚úÖ Scheduler started successfully")
        
        # ÊöÇÊó∂Á¶ÅÁî®Êô∫ËÉΩ‰∫§ÊòìÊú∫‰ºöÊâ´Êèè‰ªªÂä° - ÈÅøÂÖçÈáçÂ§çÊé®ÈÄÅ
        # from app.services.intelligent_trading_notification_service import IntelligentTradingNotificationService
        # intelligent_notification_service = IntelligentTradingNotificationService()
        logger.info("üì¥ Êô∫ËÉΩ‰∫§ÊòìÊú∫‰ºöÊâ´ÊèèÂ∑≤Á¶ÅÁî® - ‰ΩøÁî®Ê†∏ÂøÉ‰∫§ÊòìÊúçÂä°ÁöÑËØ¶ÁªÜÊé®ÈÄÅ")
        
        # ‚ùå Â∑≤ÁßªÈô§ÈáçÂ§çÁöÑKronosÂ∏ÇÂú∫Êú∫‰ºöÊâ´ÊèèÊúçÂä° - Â∑≤Êï¥ÂêàÂà∞Ë∞ÉÂ∫¶Âô®ÁöÑË∂ãÂäøÂàÜÊûê‰ªªÂä°‰∏≠
        # ÂéüÂõ†: ÈÅøÂÖç‰∏éË∞ÉÂ∫¶Âô®‰∏≠ÁöÑ_trend_analysis_jobÈáçÂ§çÂàÜÊûêÁõ∏ÂêåÂ∏ÅÁßç
        # Êñ∞ÁöÑÊï¥ÂêàÊñπÊ°à: Ë∞ÉÂ∫¶Âô®‰∏≠ÁöÑË∂ãÂäøÂàÜÊûê‰ªªÂä°Â∑≤Â¢ûÂº∫‰∏∫"KronosÊ†∏ÂøÉ‰ø°Âè∑ÂàÜÊûê"ÔºåÊØè15ÂàÜÈíüÊâßË°å
        
        # if settings.kronos_config.get('enable_kronos_prediction', False):
        #     from app.services.kronos_market_opportunity_service import get_kronos_market_opportunity_service
        #     
        #     async def kronos_strong_opportunities_scan():
        #         """KronosÂº∫‰∫§ÊòìÊú∫‰ºöÊâ´Êèè - ÊØè30ÂàÜÈíü (Â∑≤ÁßªÈô§ÔºåÈÅøÂÖçÈáçÂ§ç)"""
        #         # Ê≠§ÂäüËÉΩÂ∑≤Êï¥ÂêàÂà∞Ë∞ÉÂ∫¶Âô®ÁöÑ_trend_analysis_job‰∏≠
        #         pass
        #     
        #     # ÁßªÈô§ÈáçÂ§çÁöÑÊâ´Êèè‰ªªÂä°
        #     # scheduler.add_job(kronos_strong_opportunities_scan, ...)
        #     
        #     logger.info("üîÑ KronosÂº∫‰∫§ÊòìÊú∫‰ºöÊâ´ÊèèÂ∑≤Êï¥ÂêàÂà∞Ë∞ÉÂ∫¶Âô®Ë∂ãÂäøÂàÜÊûê‰ªªÂä°‰∏≠")
        # else:
        #     logger.info("üì¥ KronosÈ¢ÑÊµãÂ∑≤Á¶ÅÁî®")
        
        # üìù ‰ºòÂåñËØ¥Êòé: 
        # 1. ÂéüÊù•ÁöÑÂ∏ÇÂú∫Êâ´Êèè‰ªªÂä°(ÊØè30ÂàÜÈíü) + Ë∂ãÂäøÂàÜÊûê‰ªªÂä°(ÊØè15ÂàÜÈíü) = ÈáçÂ§çÂàÜÊûê
        # 2. Áé∞Âú®Áªü‰∏Ä‰∏∫Ë∞ÉÂ∫¶Âô®‰∏≠ÁöÑ"KronosÊ†∏ÂøÉ‰ø°Âè∑ÂàÜÊûê"‰ªªÂä°(ÊØè15ÂàÜÈíü)
        # 3. Êèê‰æõÊõ¥ËØ¶ÁªÜÁöÑÊäÄÊúØÂàÜÊûêÂíåÁ≤æÂáÜÁöÑ‰∫§ÊòìÂª∫ËÆÆ
        
        if settings.kronos_config.get('enable_kronos_prediction', False):
            logger.info("‚úÖ KronosÈ¢ÑÊµãÂ∑≤ÂêØÁî®ÔºåÊ†∏ÂøÉ‰ø°Âè∑ÂàÜÊûêÁî±Ë∞ÉÂ∫¶Âô®Áªü‰∏ÄÁÆ°ÁêÜ")
        else:
            logger.info("üì¥ KronosÈ¢ÑÊµãÂ∑≤Á¶ÅÁî®")
        
        # Ê∑ªÂä†Ë¥üË¥πÁéáÁõëÊéßÂÆöÊó∂‰ªªÂä°
        funding_monitor = NegativeFundingMonitorService()
        
        # ÊØè20ÂàÜÈíüÊ£ÄÊü•‰∏ÄÊ¨°Ë¥üË¥πÁéáÊú∫‰ºöÔºà‰ΩøÁî®Â¢ûÂº∫ÁâàÂàÜÊûêÔºâ
        scheduler.add_job(
            lambda: funding_monitor.run_monitoring_cycle(enable_enhanced_analysis=True),
            'interval',
            minutes=20,
            id='negative_funding_monitor',
            name='Ë¥üË¥πÁéáÂêÉÂà©ÊÅØÊú∫‰ºöÁõëÊéßÔºàÂ¢ûÂº∫ÁâàÔºâ'
        )
        logger.info("‚úÖ Negative funding rate monitor scheduled")
        
        # Ê∑ªÂä†Êñ∞ÈóªÁõëÊéßÂÆöÊó∂‰ªªÂä° - ÊöÇÊó∂Ê≥®ÈáäÊéâ
        # if settings.news_config.get('enable_news_analysis', True):
        #     from app.services.news_monitor_service import get_news_monitor_service
        #     
        #     news_monitor = await get_news_monitor_service()
        #     
        #     # Ëé∑ÂèñÊñ∞ÈóªÁõëÊéßÈó¥ÈöîÈÖçÁΩÆ
        #     news_interval = settings.news_config.get('fetch_interval_minutes', 30)
        #     
        #     scheduler.add_job(
        #         news_monitor.run_monitoring_cycle,
        #         'interval',
        #         minutes=news_interval,
        #         id='news_monitor',
        #         name='Êñ∞ÈóªÂàÜÊûêÁõëÊéß'
        #     )
        #     logger.info(f"‚úÖ News analysis monitor scheduled (every {news_interval} minutes)")
        #     
        #     # Â∞ÜÊñ∞ÈóªÁõëÊéßÊúçÂä°Â≠òÂÇ®Âà∞Â∫îÁî®Áä∂ÊÄÅ
        #     app.state.news_monitor = news_monitor
        # else:
        #     logger.info("üì¥ News analysis monitoring disabled")
        
        # Â∞ÜË¥üË¥πÁéáÁõëÊéßÊúçÂä°Â≠òÂÇ®Âà∞Â∫îÁî®Áä∂ÊÄÅ
        app.state.funding_monitor = funding_monitor
        
        # Ê∑ªÂä†KronosÊåÅ‰ªìÂàÜÊûêÂÆöÊó∂‰ªªÂä°
        if settings.kronos_config.get('enable_kronos_prediction', False):
            from app.services.kronos_position_analysis_service import get_kronos_position_service
            
            # ‰ΩøÁî®ÂÖ®Â±ÄÂçï‰æãÂÆû‰æãÔºåÁ°Æ‰øùÁä∂ÊÄÅ‰∏ÄËá¥
            kronos_position_service = await get_kronos_position_service()
            
            # ÂêØÂä®Êó∂Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°KronosÊåÅ‰ªìÂàÜÊûê
            try:
                logger.info("ü§ñ ÂêØÂä®Êó∂Á´ãÂç≥ÊâßË°åKronosÊåÅ‰ªìÂàÜÊûê...")
                startup_position_result = await kronos_position_service.run_startup_analysis()
                app.state.startup_position_analysis = startup_position_result
                
                if startup_position_result.get("status") == "success":
                    positions_count = startup_position_result.get("positions_analyzed", 0)
                    logger.info(f"‚úÖ ÂêØÂä®KronosÊåÅ‰ªìÂàÜÊûêÂÆåÊàê: ÂàÜÊûê‰∫Ü {positions_count} ‰∏™ÊåÅ‰ªì")
                elif startup_position_result.get("status") == "no_positions":
                    logger.info("üìä ÂΩìÂâçÊó†ÊåÅ‰ªìÔºåË∑≥ËøáKronosÊåÅ‰ªìÂàÜÊûê")
                else:
                    logger.warning(f"‚ö†Ô∏è ÂêØÂä®KronosÊåÅ‰ªìÂàÜÊûêÂºÇÂ∏∏: {startup_position_result.get('reason', 'Êú™Áü•')}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è ÂêØÂä®KronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•: {e}")
                app.state.startup_position_analysis = {"status": "error", "error": str(e)}
            
            # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®Áõ∏ÂêåÁöÑÂÆöÊó∂‰ªªÂä°ÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
            existing_job = scheduler.get_job('kronos_position_analysis')
            if existing_job:
                logger.warning("‚ö†Ô∏è KronosÊåÅ‰ªìÂàÜÊûê‰ªªÂä°Â∑≤Â≠òÂú®ÔºåË∑≥ËøáÈáçÂ§çÊ∑ªÂä†")
            else:
                # ÊØè60ÂàÜÈíüÊâßË°å‰∏ÄÊ¨°KronosÊåÅ‰ªìÂàÜÊûêÂíåÊé®ÈÄÅ
                scheduler.add_job(
                    kronos_position_service.run_scheduled_analysis,
                    'interval',
                    minutes=60,
                    id='kronos_position_analysis',
                    name='KronosÊåÅ‰ªìÂàÜÊûêÂíåÈ£éÈô©ËØÑ‰º∞',
                    max_instances=1  # Á°Æ‰øùÂêåÊó∂Âè™Êúâ‰∏Ä‰∏™ÂÆû‰æãËøêË°å
                )
                logger.info("‚úÖ KronosÊåÅ‰ªìÂàÜÊûêÂÆöÊó∂‰ªªÂä°Â∑≤ÂêØÂä® (ÊØè60ÂàÜÈíü)")
            
            # Â∞ÜÊúçÂä°Â≠òÂÇ®Âà∞Â∫îÁî®Áä∂ÊÄÅ
            app.state.kronos_position_service = kronos_position_service
        
        # üöÄ ÂêØÂä®Êó∂Âπ∂ÂèëÊâßË°åÊâÄÊúâÂàÜÊûê‰ªªÂä° - ÂºÇÊ≠•‰ºòÂåñ
        logger.info("üöÄ ÂºÄÂßãÂπ∂ÂèëÊâßË°åÂêØÂä®ÂàÜÊûê‰ªªÂä°...")
        startup_tasks = []
        
        # 1. Ê†∏ÂøÉ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûê‰ªªÂä°
        startup_tasks.append(("trading_analysis", perform_startup_trading_analysis()))
        
        # 2. Ë¥üË¥πÁéáÂàÜÊûê‰ªªÂä°
        startup_tasks.append(("funding_analysis", perform_startup_funding_analysis()))
        
        # 3. Êñ∞ÈóªÂàÜÊûê‰ªªÂä° (Â¶ÇÊûúÂêØÁî®) - ÊöÇÊó∂Ê≥®ÈáäÊéâ
        # if settings.news_config.get('enable_news_analysis', True):
        #     startup_tasks.append(("news_analysis", perform_startup_news_analysis()))
        
        # 4. KronosÂ∏ÇÂú∫Êú∫‰ºöÊâ´Êèè‰ªªÂä° - Â∑≤Êï¥ÂêàÂà∞Ê†∏ÂøÉ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûê‰∏≠ÔºåÈÅøÂÖçÈáçÂ§çÊé®ÈÄÅ
        # ÂéüÂõ†: perform_startup_trading_analysis() Â∑≤ÁªèÂåÖÂê´‰∫ÜKronosÂàÜÊûêÂäüËÉΩ
        # ‰∏çÂÜçÈúÄË¶ÅÂçïÁã¨ÁöÑÂ∏ÇÂú∫Êâ´Êèè‰ªªÂä°
        logger.info("üîÑ KronosÂ∏ÇÂú∫Êâ´ÊèèÂ∑≤Êï¥ÂêàÂà∞Ê†∏ÂøÉ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûê‰∏≠ÔºåÈÅøÂÖçÈáçÂ§çÊé®ÈÄÅ")
        
        # Âπ∂ÂèëÊâßË°åÊâÄÊúâÂêØÂä®‰ªªÂä°
        task_names = [name for name, _ in startup_tasks]
        task_coroutines = [task for _, task in startup_tasks]
        
        logger.info(f"üìä ÂáÜÂ§áÂπ∂ÂèëÊâßË°å {len(task_coroutines)} ‰∏™ÂêØÂä®‰ªªÂä°: {task_names}")
        
        # ‰ΩøÁî® asyncio.gather Âπ∂ÂèëÊâßË°åÔºåÂÖÅËÆ∏ÈÉ®ÂàÜÂ§±Ë¥•
        startup_results = await asyncio.gather(*task_coroutines, return_exceptions=True)
        
        # Â§ÑÁêÜÂπ∂ÂèëÊâßË°åÁªìÊûú
        successful_tasks = 0
        failed_tasks = 0
        
        for i, (task_name, result) in enumerate(zip(task_names, startup_results)):
            if isinstance(result, Exception):
                logger.warning(f"‚ö†Ô∏è ÂêØÂä®‰ªªÂä° {task_name} Â§±Ë¥•: {result}")
                setattr(app.state, f"startup_{task_name}_results", {"status": "error", "error": str(result)})
                failed_tasks += 1
            else:
                logger.info(f"‚úÖ ÂêØÂä®‰ªªÂä° {task_name} ÂÆåÊàê")
                setattr(app.state, f"startup_{task_name}_results", result)
                successful_tasks += 1
        
        # ËÆ∞ÂΩïÂπ∂ÂèëÊâßË°åÊÄªÁªì
        total_tasks = len(task_coroutines)
        logger.info(f"üéØ ÂêØÂä®‰ªªÂä°Âπ∂ÂèëÊâßË°åÂÆåÊàê: {successful_tasks}/{total_tasks} ÊàêÂäü, {failed_tasks} Â§±Ë¥•")
        
        # ËÆæÁΩÆÈªòËÆ§Áä∂ÊÄÅ (ÂÖºÂÆπÊÄß)
        if not hasattr(app.state, 'startup_news_analysis_results'):
            app.state.startup_news_analysis_results = {"status": "disabled"}
        if not hasattr(app.state, 'startup_kronos_market_scan_results'):
            app.state.startup_kronos_market_scan_results = {"status": "disabled"}
        
        # üö´ ‰∏çÂÜçÂèëÈÄÅÂêØÂä®ÂÆåÊàêÊëòË¶ÅÈÄöÁü• - Ê†πÊçÆÁî®Êà∑Ë¶ÅÊ±ÇËøáÊª§Á≥ªÁªüÁä∂ÊÄÅ‰ø°ÊÅØ
        # await send_startup_summary_notification(app.state, successful_tasks, failed_tasks)
        logger.info("üìä ÂêØÂä®ÊëòË¶ÅÈÄöÁü•Â∑≤Á¶ÅÁî® - Á≥ªÁªüÁä∂ÊÄÅ‰ø°ÊÅØ‰∏çÊé®ÈÄÅ")
        
        # ÂàùÂßãÂåñKronosÈ¢ÑÊµãÊúçÂä°ÔºàÂèØÈÄâÔºâ
        if settings.kronos_config.get('enable_kronos_prediction', False):
            try:
                from app.services.kronos_prediction_service import get_kronos_service
                kronos_service = await get_kronos_service()
                logger.info("‚úÖ KronosÈ¢ÑÊµãÊúçÂä°ÂàùÂßãÂåñÊàêÂäü")
                app.state.kronos_service = kronos_service
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è KronosÈ¢ÑÊµãÊúçÂä°ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
                logger.info("üí° KronosÊúçÂä°Â∞ÜÂú®È¶ñÊ¨°Ë∞ÉÁî®Êó∂Â∞ùËØïÈáçÊñ∞ÂàùÂßãÂåñ")
                app.state.kronos_service = None
        
        # ÂàùÂßãÂåñMLÂ¢ûÂº∫ÊúçÂä°ÔºàÂèØÈÄâÔºâ
        if settings.ml_config.get('enable_ml_prediction', False):
            ml_service = MLEnhancedService()
            try:
                await ml_service.initialize_models(settings.monitored_symbols)
                logger.info("‚úÖ MLÂ¢ûÂº∫ÊúçÂä°ÂàùÂßãÂåñÊàêÂäü")
                app.state.ml_service = ml_service
                
                # ÂêØÂä®Êó∂MLÂ¢ûÂº∫ÂàÜÊûê - Â∑≤ÂÅúÁî®ÈÅøÂÖçÂºÇÂ∏∏Ê£ÄÊµãÊä•ÂëäÊé®ÈÄÅ
                # await perform_startup_ml_analysis(ml_service)
                logger.info("‚ö†Ô∏è ÂêØÂä®Êó∂MLÂºÇÂ∏∏Ê£ÄÊµãÂ∑≤ÂÅúÁî®ÈÅøÂÖçÈáçÂ§çÊé®ÈÄÅ")
                
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è MLÂ¢ûÂº∫ÊúçÂä°ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
                app.state.ml_service = None
        
        # Â∞ÜÊúçÂä°ÂÆû‰æãÂ≠òÂÇ®Âà∞Â∫îÁî®Áä∂ÊÄÅ
        app.state.scheduler = scheduler
        
        logger.info("üéâ Application startup completed!")
        
        yield
        
        # Â∫îÁî®ÂÖ≥Èó≠Êó∂ÁöÑÊ∏ÖÁêÜÂ∑•‰Ωú
        logger.info("üõë Shutting down application...")
        
        # 1. ÂÅúÊ≠¢Ë∞ÉÂ∫¶Âô®
        try:
            if hasattr(app.state, 'scheduler') and app.state.scheduler:
                await app.state.scheduler.shutdown()
                logger.info("‚úÖ Scheduler stopped")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error stopping scheduler: {e}")
        
        # 2. Ê∏ÖÁêÜÊ†∏ÂøÉHTTPÂÆ¢Êà∑Á´Ø
        try:
            from app.core.http_client import cleanup_http_resources
            await cleanup_http_resources()
            logger.info("‚úÖ Core HTTP client cleaned up")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error cleaning up core HTTP client: {e}")
        
        # 3. Ê∏ÖÁêÜ OKX ÊúçÂä°ËøûÊé•
        try:
            from app.services.okx_service import cleanup_all_sessions
            await cleanup_all_sessions()
            logger.info("‚úÖ OKX HTTP connections cleaned up")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error cleaning up OKX connections: {e}")
        
        # 4. ÈÄöÁî® HTTP ËøûÊé•Ê∏ÖÁêÜÔºàÂÖºÂÆπÊÄßÔºâ
        try:
            import gc
            import aiohttp
            
            # Êî∂ÈõÜÊâÄÊúâÂâ©‰ΩôÁöÑ aiohttp.ClientSession ÂØπË±°Âπ∂ÂÖ≥Èó≠
            cleaned_count = 0
            for obj in gc.get_objects():
                if isinstance(obj, aiohttp.ClientSession) and not obj.closed:
                    try:
                        await obj.close()
                        cleaned_count += 1
                    except Exception as e:
                        logger.debug(f"‚ö†Ô∏è Error closing remaining session: {e}")
            
            if cleaned_count > 0:
                await asyncio.sleep(0.2)
                logger.info(f"‚úÖ Cleaned up {cleaned_count} remaining HTTP sessions")
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error in general HTTP cleanup: {e}")
        
        # 4. Ê∏ÖÁêÜÊï∞ÊçÆÂ∫ìËøûÊé•
        try:
            if hasattr(app.state, 'database_available') and app.state.database_available and db_manager:
                await db_manager.close_all_connections()
                logger.info("‚úÖ Database connections closed")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error closing database connections: {e}")
        
        # 5. Ê∏ÖÁêÜÂÖ∂‰ªñÊúçÂä°
        try:
            # Ê∏ÖÁêÜ Kronos ÊúçÂä°
            if hasattr(app.state, 'kronos_service') and app.state.kronos_service:
                # Kronos ÊúçÂä°ÈÄöÂ∏∏‰∏çÈúÄË¶ÅÁâπÊÆäÊ∏ÖÁêÜ
                pass
            
            # Ê∏ÖÁêÜ ML ÊúçÂä°
            if hasattr(app.state, 'ml_service') and app.state.ml_service:
                # ML ÊúçÂä°ÈÄöÂ∏∏‰∏çÈúÄË¶ÅÁâπÊÆäÊ∏ÖÁêÜ
                pass
                
            logger.info("‚úÖ Services cleaned up")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error cleaning up services: {e}")
        
        logger.info("üéØ Application shutdown completed")
        
    except Exception as e:
        logger.error(f"‚ùå Application startup failed: {e}")
        raise
    
    # ÂÖ≥Èó≠Êó∂ÊâßË°å
    logger.info("üõë Shutting down Python Trading Analysis Tool...")
    
    try:
        # ÂÅúÊ≠¢Ë∞ÉÂ∫¶Âô®
        if hasattr(app.state, 'scheduler'):
            await app.state.scheduler.stop()
            logger.info("‚úÖ Scheduler stopped")
        
        # Ê∏ÖÁêÜHTTPËøûÊé•Ê±†
        try:
            from app.utils.http_manager import cleanup_http_resources
            await cleanup_http_resources()
            logger.info("‚úÖ HTTP connection pool cleaned up")
        except Exception as e:
            logger.error(f"‚ö†Ô∏è HTTP cleanup error: {e}")
        
        # Ê∏ÖÁêÜÊï∞ÊçÆÂ∫ìËøûÊé•
        try:
            if db_manager:
                db_manager.close_all_connections()
                logger.info("‚úÖ Database connections closed")
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Database cleanup error: {e}")
        
        logger.info("üëã Application shutdown completed!")
        
    except Exception as e:
        logger.error(f"‚ùå Application shutdown error: {e}")

def create_app() -> FastAPI:
    """ÂàõÂª∫FastAPIÂ∫îÁî®"""
    
    app = FastAPI(
        title="Python Trading Analysis Tool",
        description="Python ‰∫§ÊòìÂàÜÊûêÂ∑•ÂÖ∑ - Êèê‰æõË∂ãÂäøÂàÜÊûê„ÄÅË¥πÁéáÁõëÊéß„ÄÅÊåÅ‰ªìÈáèÂèòÂåñÁõëÊéßÁ≠âÂäüËÉΩ",
        version=settings.app_version,
        docs_url="/docs" if settings.debug else None,
        redoc_url="/redoc" if settings.debug else None,
        lifespan=lifespan
    )
    
    # Ê∑ªÂä†CORS‰∏≠Èó¥‰ª∂
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"] if settings.debug else ["http://localhost:3000"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Ê≥®ÂÜåË∑ØÁî± - Ê†∏ÂøÉÊï¥ÂêàAPI‰ºòÂÖà
    app.include_router(core_trading_router, tags=["Ê†∏ÂøÉ‰∫§Êòì"])
    
    # ÂéüÊúâË∑ØÁî± - ‰øùÊåÅÂÖºÂÆπÊÄß
    app.include_router(trend_router, prefix="/api/trend", tags=["Ë∂ãÂäøÂàÜÊûê"])
    app.include_router(monitor_router, prefix="/api/monitor", tags=["ÁõëÊéßÊúçÂä°"])
    app.include_router(notification_router, prefix="/api/notification", tags=["ÈÄöÁü•ÊúçÂä°"])
    app.include_router(tradingview_router, prefix="/api/tradingview", tags=["TradingViewÂäüËÉΩ"])
    app.include_router(strategy_router, prefix="/api/strategy", tags=["Á≠ñÁï•ÂàÜÊûê"])
    app.include_router(ml_enhanced_router, prefix="/api/ml", tags=["Êú∫Âô®Â≠¶‰π†Â¢ûÂº∫"])
    app.include_router(backtest_router, prefix="/api", tags=["ÂõûÊµãÂàÜÊûê"])
    app.include_router(funding_monitor_router, prefix="/api/funding", tags=["Ë¥üË¥πÁéáÁõëÊéß"])
    app.include_router(kronos_router, prefix="/api/kronos", tags=["Kronos AIÈ¢ÑÊµã"])
    app.include_router(kronos_integrated_router, prefix="/api/kronos-integrated", tags=["KronosÈõÜÊàêÂÜ≥Á≠ñ"])
    app.include_router(kronos_market_opportunities_router, prefix="/api/kronos-opportunities", tags=["KronosÂ∏ÇÂú∫Êú∫‰ºö"])
    app.include_router(kronos_advanced_opportunities_router, prefix="/api/kronos-advanced", tags=["KronosÈ´òÁ∫ßÊú∫‰ºö"])
    app.include_router(notification_stats_router)
    app.include_router(database_router, prefix="/api/database", tags=["Êï∞ÊçÆÂ∫ìÁÆ°ÁêÜ"])
    app.include_router(http_pool_router, prefix="/api/http-pool", tags=["HTTPËøûÊé•Ê±†ÁÆ°ÁêÜ"])
    app.include_router(trading_pairs_router, prefix="/api/trading-pairs", tags=["‰∫§ÊòìÂØπÁÆ°ÁêÜ"])
    app.include_router(unified_data_router, prefix="/api", tags=["Áªü‰∏ÄÊï∞ÊçÆÊúçÂä°"])
    app.include_router(ml_config_router, prefix="/api/ml-config", tags=["MLÈÖçÁΩÆÁÆ°ÁêÜ"])
    app.include_router(news_router, prefix="/api/news", tags=["Êñ∞ÈóªÂàÜÊûê"])
    
    # Ê†πË∑ØÂæÑ
    @app.get("/", summary="Ê†πË∑ØÂæÑ")
    async def root():
        return {
            "message": "Welcome to Python Trading Analysis Tool",
            "version": settings.app_version,
            "status": "running",
            "docs": "/docs" if settings.debug else "disabled"
        }
    
    # ÂÅ•Â∫∑Ê£ÄÊü•
    @app.get("/health", summary="ÂÅ•Â∫∑Ê£ÄÊü•")
    async def health_check():
        try:
            # Ê£ÄÊü•Êï∞ÊçÆÂ∫ìËøûÊé•ÂíåËøûÊé•Ê±†
            db_healthy = False
            pool_stats = {}
            if DATABASE_AVAILABLE and db_manager and get_db_monitor:
                db_healthy = db_manager.health_check()
                db_monitor = get_db_monitor()
                pool_stats = db_monitor.get_pool_stats() if db_healthy else {}
            
            # TODO: Ê£ÄÊü•Â∏ÅÂÆâAPIËøûÊé•
            api_healthy = True  # ÊöÇÊó∂ËÆæ‰∏∫True
            
            # Ê£ÄÊü•Ë∞ÉÂ∫¶Âô®Áä∂ÊÄÅ
            scheduler_healthy = hasattr(app.state, 'scheduler') and app.state.scheduler.is_running()
            
            # Ê£ÄÊü•MLÊúçÂä°Áä∂ÊÄÅ
            ml_healthy = True
            if settings.ml_config.get('enable_ml_prediction', False):
                ml_healthy = hasattr(app.state, 'ml_service') and app.state.ml_service is not None
            
            status = "healthy" if all([db_healthy, api_healthy, scheduler_healthy, ml_healthy]) else "unhealthy"
            
            health_checks = {
                "database": "healthy" if db_healthy else "unhealthy",
                "connection_pool": pool_stats,
                "binance_api": "healthy" if api_healthy else "unhealthy", 
                "scheduler": "healthy" if scheduler_healthy else "unhealthy"
            }
            
            if settings.ml_config.get('enable_ml_prediction', False):
                health_checks["ml_service"] = "healthy" if ml_healthy else "unhealthy"
            
            return {
                "status": status,
                "timestamp": datetime.now().isoformat(),
                "checks": health_checks
            }
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            raise HTTPException(status_code=500, detail="Health check failed")
    
    # ÂêØÂä®ÂàÜÊûêÁªìÊûú
    @app.get("/startup-analysis", summary="Êü•ÁúãÂêØÂä®ÂàÜÊûêÁªìÊûú")
    async def get_startup_analysis():
        """Ëé∑ÂèñÂ∫îÁî®ÂêØÂä®Êó∂ÁöÑ‰∫§ÊòìÂàÜÊûêÁªìÊûú"""
        try:
            trading_results = None
            funding_results = None
            kronos_results = None
            
            if hasattr(app.state, 'startup_analysis_results'):
                trading_results = app.state.startup_analysis_results
                
            if hasattr(app.state, 'startup_funding_results'):
                funding_results = app.state.startup_funding_results
                
            if hasattr(app.state, 'startup_kronos_results'):
                kronos_results = app.state.startup_kronos_results
            
            return {
                "status": "success",
                "startup_analysis": {
                    "trading_analysis": trading_results,
                    "funding_analysis": funding_results,
                    "kronos_market_scan": kronos_results
                },
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂêØÂä®ÂàÜÊûêÁªìÊûúÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñÂêØÂä®ÂàÜÊûêÁªìÊûúÂ§±Ë¥•")
    
    # KronosÂ∏ÇÂú∫Êú∫‰ºöÂø´ÈÄüÊµãËØï
    @app.get("/kronos-opportunities-test", summary="KronosÂ∏ÇÂú∫Êú∫‰ºöÂø´ÈÄüÊµãËØï")
    async def test_kronos_opportunities():
        """Âø´ÈÄüÊµãËØïKronosÂ∏ÇÂú∫Êú∫‰ºöÊâ´ÊèèÂäüËÉΩ"""
        try:
            from app.services.kronos_market_opportunity_service import get_kronos_market_opportunity_service
            
            market_service = await get_kronos_market_opportunity_service()
            
            # Ëé∑ÂèñÊâ´ÊèèÁä∂ÊÄÅ
            status = await market_service.get_scan_status()
            
            # ÊâßË°åÂø´ÈÄüÂº∫‰ø°Âè∑Êâ´ÊèèÔºàÂº∫Âà∂Ê®°ÂºèÔºâ
            strong_result = await market_service.scan_strong_trading_opportunities(force_scan=True)
            
            return {
                "status": "success",
                "scan_status": status,
                "test_scan_result": strong_result,
                "message": "KronosÂ∏ÇÂú∫Êú∫‰ºöÊâ´ÊèèÊµãËØïÂÆåÊàê",
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"KronosÊú∫‰ºöÊµãËØïÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"ÊµãËØïÂ§±Ë¥•: {str(e)}")
    
    # Ë¥üË¥πÁéáÊú∫‰ºöÂø´ÈÄüÊü•Áúã
    @app.get("/funding-opportunities", summary="Âø´ÈÄüÊü•ÁúãË¥üË¥πÁéáÊú∫‰ºö")
    async def get_funding_opportunities():
        """Âø´ÈÄüÊü•ÁúãÂΩìÂâçË¥üË¥πÁéáÂêÉÂà©ÊÅØÊú∫‰ºö"""
        try:
            if hasattr(app.state, 'funding_monitor'):
                # ‰ΩøÁî®ÁºìÂ≠òÁöÑÁõëÊéßÊúçÂä°ËøõË°åÂø´ÈÄüÊ£ÄÊü•
                funding_monitor = app.state.funding_monitor
                
                # Âø´ÈÄüÊ£ÄÊü•Ââç20‰∏™ÁÉ≠Èó®Â∏ÅÁßç
                hot_symbols = await funding_monitor.get_top_volume_symbols(limit=20)
                
                # ‰ΩøÁî®OKXÊúçÂä°Ëé∑ÂèñË¥πÁéáÊï∞ÊçÆ
                async with funding_monitor.okx_service:
                    funding_rates = await funding_monitor.okx_service.get_batch_funding_rates(hot_symbols[:15])
                
                # Âè™ÂàÜÊûêË¥üË¥πÁéáÂ∏ÅÁßç
                negative_rates = [r for r in funding_rates if r['funding_rate'] < 0]
                
                if negative_rates:
                    opportunities = []
                    for rate_data in negative_rates:
                        daily_rate = rate_data['funding_rate'] * 3
                        opportunities.append({
                            'symbol': rate_data['symbol'].replace('-USDT-SWAP', ''),
                            'funding_rate_percent': rate_data['funding_rate'] * 100,
                            'daily_rate_percent': abs(daily_rate * 100),
                            'daily_income_10k': abs(daily_rate * 10000),
                            'annual_rate_percent': abs(daily_rate * 365 * 100)
                        })
                    
                    opportunities.sort(key=lambda x: x['funding_rate_percent'])
                    
                    return {
                        "status": "success",
                        "message": f"ÂèëÁé∞ {len(opportunities)} ‰∏™Ë¥üË¥πÁéáÊú∫‰ºö",
                        "opportunities": opportunities[:8],
                        "timestamp": datetime.now().isoformat()
                    }
                else:
                    return {
                        "status": "success",
                        "message": "ÂΩìÂâçÊó†Ë¥üË¥πÁéáÊú∫‰ºö",
                        "opportunities": [],
                        "timestamp": datetime.now().isoformat()
                    }
            else:
                return {
                    "status": "error",
                    "message": "Ë¥üË¥πÁéáÁõëÊéßÊúçÂä°Êú™ÂêØÂä®",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñË¥üË¥πÁéáÊú∫‰ºöÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñË¥üË¥πÁéáÊú∫‰ºöÂ§±Ë¥•")
    
    # ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéß
    @app.post("/test-funding-monitor", summary="ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéß")
    async def test_funding_monitor():
        """ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéßÔºåÁî®‰∫éÊµãËØïÊé®ÈÄÅÂäüËÉΩ"""
        try:
            if hasattr(app.state, 'funding_monitor'):
                funding_monitor = app.state.funding_monitor
                logger.info("üß™ ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéßÊµãËØï...")
                
                # ËøêË°åÂÆåÊï¥ÁöÑÁõëÊéßÂë®Êúü
                result = await funding_monitor.run_monitoring_cycle(enable_enhanced_analysis=True)
                
                if result['success']:
                    return {
                        "status": "success",
                        "message": f"ÁõëÊéßÂÆåÊàêÔºåÂèëÁé∞ {result.get('negative_funding_count', 0)} ‰∏™Ë¥üË¥πÁéáÊú∫‰ºö",
                        "data": {
                            "total_symbols_checked": result.get('total_symbols_checked', 0),
                            "opportunities_count": result.get('negative_funding_count', 0),
                            "duration_seconds": result.get('duration_seconds', 0),
                            "analysis_time": result.get('analysis_time')
                        },
                        "timestamp": datetime.now().isoformat()
                    }
                else:
                    return {
                        "status": "error",
                        "message": f"ÁõëÊéßÂ§±Ë¥•: {result.get('error', 'Êú™Áü•ÈîôËØØ')}",
                        "timestamp": datetime.now().isoformat()
                    }
            else:
                return {
                    "status": "error",
                    "message": "Ë¥üË¥πÁéáÁõëÊéßÊúçÂä°Êú™ÂêØÂä®",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéßÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"ÁõëÊéßÂ§±Ë¥•: {str(e)}")
    
    # Âø´ÈÄüÂ∏ÇÂú∫Ê¶ÇËßà
    @app.get("/market-overview", summary="Âø´ÈÄüÂ∏ÇÂú∫Ê¶ÇËßà")
    async def get_market_overview():
        """Ëé∑ÂèñÂΩìÂâçÂ∏ÇÂú∫Âø´ÈÄüÊ¶ÇËßà"""
        try:
            from app.services.startup_trading_service import StartupTradingService
            startup_service = StartupTradingService()
            
            overview = await startup_service.get_quick_market_overview()
            
            return {
                "status": "success",
                "market_overview": overview,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂ∏ÇÂú∫Ê¶ÇËßàÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñÂ∏ÇÂú∫Ê¶ÇËßàÂ§±Ë¥•")
    
    # KronosÊåÅ‰ªìÂàÜÊûêÊä•Âëä
    @app.get("/kronos-position-analysis", summary="KronosÊåÅ‰ªìÂàÜÊûêÊä•Âëä")
    async def get_kronos_position_analysis():
        """Ëé∑ÂèñÂü∫‰∫éKronosÈ¢ÑÊµãÁöÑÊåÅ‰ªìÂàÜÊûêÊä•Âëä"""
        try:
            from app.services.kronos_integrated_decision_service import get_kronos_integrated_service
            
            kronos_service = await get_kronos_integrated_service()
            
            # ÂàÜÊûê‰∏ªË¶ÅÊåÅ‰ªìÂ∏ÅÁßç
            symbols = ["ETH-USDT-SWAP", "SOL-USDT-SWAP"]
            analysis_results = {}
            
            for symbol in symbols:
                decision = await kronos_service.get_kronos_enhanced_decision(symbol, force_update=True)
                if decision:
                    analysis_results[symbol] = {
                        "symbol": symbol.replace("-USDT-SWAP", ""),
                        "kronos_confidence": decision.kronos_confidence,
                        "signal_strength": decision.kronos_signal_strength.value,
                        "final_action": decision.final_action,
                        "final_confidence": decision.final_confidence,
                        "reasoning": decision.reasoning,
                        "kronos_analysis": getattr(decision, 'kronos_analysis', {}),
                        "position_recommendation": decision.position_recommendation.value if decision.position_recommendation else "Êó†Âª∫ËÆÆ",
                        "risk_level": decision.position_risk.value if decision.position_risk else "Êú™Áü•"
                    }
            
            return {
                "status": "success",
                "message": f"KronosÊåÅ‰ªìÂàÜÊûêÂÆåÊàêÔºåÂàÜÊûê‰∫Ü {len(analysis_results)} ‰∏™Â∏ÅÁßç",
                "analysis_results": analysis_results,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñKronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñKronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•")
    
    # ÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûê (Âü∫‰∫éÂÆûÈôÖÊåÅ‰ªì)
    @app.get("/kronos-live-position-analysis", summary="ÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûê")
    async def get_kronos_live_position_analysis():
        """Ëé∑ÂèñÂü∫‰∫éÂÆûÈôÖÊåÅ‰ªìÁöÑKronosÂàÜÊûêÊä•Âëä"""
        try:
            from app.services.kronos_position_analysis_service import get_kronos_position_service
            
            kronos_position_service = await get_kronos_position_service()
            
            # ÊâßË°åÂÆûÊó∂ÂàÜÊûê
            analysis_result = await kronos_position_service.get_manual_analysis()
            
            return {
                "status": "success",
                "message": "ÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûêÂÆåÊàê",
                "analysis_result": analysis_result,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•")
    
    # Ë∞ÉËØï‰∫§Êòì‰ø°Âè∑ÂàÜÊûê
    @app.get("/debug-trading-signals", summary="Ë∞ÉËØï‰∫§Êòì‰ø°Âè∑ÂàÜÊûê")
    async def debug_trading_signals():
        """Ë∞ÉËØï‰∫§Êòì‰ø°Âè∑ÂàÜÊûêÔºåÂ∏ÆÂä©ËØäÊñ≠‰∏∫‰ªÄ‰πàÊ≤°ÊúâÊé®ÈÄÅ‰∫§Êòì‰ø°Âè∑"""
        try:
            from app.services.intelligent_trading_notification_service import get_intelligent_notification_service
            
            intelligent_service = await get_intelligent_notification_service()
            debug_results = await intelligent_service.debug_signal_analysis()
            
            return {
                "status": "success",
                "message": "‰∫§Êòì‰ø°Âè∑Ë∞ÉËØïÂàÜÊûêÂÆåÊàê",
                "debug_results": debug_results
            }
        except Exception as e:
            logger.error(f"Ë∞ÉËØï‰∫§Êòì‰ø°Âè∑ÂàÜÊûêÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ë∞ÉËØï‰∫§Êòì‰ø°Âè∑ÂàÜÊûêÂ§±Ë¥•")
    
    # Âº∫Âà∂Êâ´Êèè‰∫§ÊòìÊú∫‰ºö
    @app.get("/test-technical-config", summary="ÊµãËØïÊäÄÊúØÂàÜÊûêÈÖçÁΩÆ")
    async def test_technical_config():
        """ÊµãËØïÊäÄÊúØÂàÜÊûêÈÖçÁΩÆÊòØÂê¶Ê≠£Á°Æ"""
        try:
            from app.core.technical_analysis_config import get_technical_config
            
            config_manager = get_technical_config()
            config = config_manager.get_config()
            
            # È™åËØÅÊùÉÈáç
            total_weight = sum(config.indicator_weights.values())
            
            return {
                "status": "success",
                "weights": config.indicator_weights,
                "total_weight": total_weight,
                "is_valid": total_weight == 100,
                "rsi_params": {
                    "period": config.rsi_period,
                    "overbought": config.rsi_overbought,
                    "oversold": config.rsi_oversold
                },
                "macd_params": {
                    "fast": config.macd_fast,
                    "slow": config.macd_slow,
                    "signal": config.macd_signal
                }
            }
            
        except Exception as e:
            logger.error(f"ÊµãËØïÊäÄÊúØÂàÜÊûêÈÖçÁΩÆÂ§±Ë¥•: {e}")
            return {"status": "error", "message": str(e)}
    
    @app.post("/test-enhanced-analysis", summary="ÊµãËØïÂ¢ûÂº∫ÁöÑÁªºÂêàÂàÜÊûê")
    async def test_enhanced_analysis(symbol: str = "BTC-USDT-SWAP"):
        """ÊµãËØïKronos+ÊäÄÊúØÂàÜÊûê+MLÁöÑÁªºÂêàÂàÜÊûê"""
        try:
            from app.services.core_trading_service import get_core_trading_service, AnalysisType
            
            core_trading_service = await get_core_trading_service()
            
            # ÊâßË°åÁªºÂêàÂàÜÊûê
            trading_signal = await core_trading_service.analyze_symbol(
                symbol=symbol,
                analysis_type=AnalysisType.INTEGRATED,
                force_update=True
            )
            
            if not trading_signal:
                return {"status": "error", "message": f"ÂàÜÊûê {symbol} Â§±Ë¥•"}
            
            # ÊûÑÂª∫ËØ¶ÁªÜÁöÑÂàÜÊûêÁªìÊûú
            result = {
                "status": "success",
                "symbol": symbol,
                "analysis_time": trading_signal.timestamp.isoformat(),
                "final_decision": {
                    "action": trading_signal.final_action,
                    "confidence": trading_signal.final_confidence,
                    "signal_strength": trading_signal.signal_strength.value if hasattr(trading_signal.signal_strength, 'value') else str(trading_signal.signal_strength)
                },
                "analysis_breakdown": {
                    "kronos": {
                        "confidence": trading_signal.confidence_breakdown.get('kronos', 0),
                        "action": trading_signal.kronos_result.final_action if trading_signal.kronos_result else None,
                        "available": trading_signal.kronos_result is not None
                    },
                    "technical": {
                        "confidence": trading_signal.confidence_breakdown.get('technical', 0),
                        "action": trading_signal.technical_result.get('action') if trading_signal.technical_result else None,
                        "available": trading_signal.technical_result is not None
                    },
                    "ml": {
                        "confidence": trading_signal.confidence_breakdown.get('ml', 0),
                        "signal": trading_signal.ml_result.get('signal') if trading_signal.ml_result else None,
                        "available": trading_signal.ml_result is not None
                    }
                },
                "technical_indicators": trading_signal.technical_indicators,
                "key_factors": trading_signal.key_factors,
                "reasoning": trading_signal.reasoning,
                "entry_price": trading_signal.entry_price
            }
            
            # ÊµãËØïÊé®ÈÄÅÈÄöÁü•
            notification_sent = await core_trading_service.send_trading_signal_notification(trading_signal)
            result["notification_sent"] = notification_sent
            
            return result
            
        except Exception as e:
            logger.error(f"ÊµãËØïÂ¢ûÂº∫ÂàÜÊûêÂ§±Ë¥•: {e}")
            return {"status": "error", "message": str(e)}
    
    @app.post("/force-scan-opportunities", summary="Âº∫Âà∂Êâ´Êèè‰∫§ÊòìÊú∫‰ºö")
    async def force_scan_opportunities():
        """Âº∫Âà∂Êâ´Êèè‰∫§ÊòìÊú∫‰ºöÂπ∂Êé®ÈÄÅÈÄöÁü•"""
        try:
            from app.services.intelligent_trading_notification_service import get_intelligent_notification_service
            
            intelligent_service = await get_intelligent_notification_service()
            scan_results = await intelligent_service.scan_and_notify_opportunities(force_scan=True)
            
            return {
                "status": "success",
                "message": "Âº∫Âà∂Êâ´Êèè‰∫§ÊòìÊú∫‰ºöÂÆåÊàê",
                "scan_results": scan_results
            }
        except Exception as e:
            logger.error(f"Âº∫Âà∂Êâ´Êèè‰∫§ÊòìÊú∫‰ºöÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Âº∫Âà∂Êâ´Êèè‰∫§ÊòìÊú∫‰ºöÂ§±Ë¥•")
    
    return app

def main():
    """‰∏ªÂáΩÊï∞"""
    try:
        logger.info(f"üöÄ Starting server on {settings.host}:{settings.port}")
        logger.info(f"üìã Debug mode: {settings.debug}")
        logger.info(f"üìä Log level: {settings.log_level}")
        
        # ÂàõÂª∫Â∫îÁî®
        app = create_app()
        
        # ÂêØÂä®ÊúçÂä°Âô®
        if settings.debug:
            # ÂºÄÂèëÊ®°ÂºèÔºö‰ΩøÁî®importÂ≠óÁ¨¶‰∏≤‰ª•ÊîØÊåÅÁÉ≠ÈáçËΩΩ
            uvicorn.run(
                "main:create_app",
                host=settings.host,
                port=settings.port,
                log_level=settings.log_level.lower(),
                reload=True,
                access_log=True,
                factory=True
            )
        else:
            # Áîü‰∫ßÊ®°ÂºèÔºöÁõ¥Êé•‰º†ÈÄíappÂØπË±°
            uvicorn.run(
                app,
                host=settings.host,
                port=settings.port,
                log_level=settings.log_level.lower(),
                access_log=True
            )
        
    except KeyboardInterrupt:
        logger.info("üõë Server stopped by user")
    except Exception as e:
        logger.error(f"‚ùå Server startup failed: {e}")
        raise

if __name__ == "__main__":
    main()
