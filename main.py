# -*- coding: utf-8 -*-
"""
Python Trading Analysis Tool - ‰∏ªÁ®ãÂ∫èÂÖ•Âè£
Main entry point for the Python Trading Analysis Tool
"""

import sys
import os
import uvicorn
import asyncio
import tracemalloc
import warnings
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

# WindowsÂπ≥Âè∞‰ºòÂåñÔºöÈÅøÂÖçmultiprocessingÂíåSQLAlchemyÁöÑÂÖºÂÆπÊÄßÈóÆÈ¢ò
if sys.platform == "win32":
    # ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáèÈÅøÂÖçSQLAlchemyÁöÑWMIÊü•ËØ¢ÈóÆÈ¢ò
    os.environ["SQLALCHEMY_WARN_20"] = "1"
    os.environ["PROCESSOR_ARCHITECTURE"] = "AMD64"
    
    # ËÆæÁΩÆmultiprocessingÂêØÂä®ÊñπÊ≥ï‰∏∫spawnÔºàWindowsÈªòËÆ§Ôºâ
    import multiprocessing
    try:
        multiprocessing.set_start_method('spawn', force=True)
    except RuntimeError:
        # Â¶ÇÊûúÂ∑≤ÁªèËÆæÁΩÆËøáÔºåÂøΩÁï•ÈîôËØØ
        pass

# ÂêØÁî® tracemalloc ‰ª•Ëé∑ÂæóÊõ¥Â•ΩÁöÑ asyncio Ë∞ÉËØï‰ø°ÊÅØ
tracemalloc.start()

# ËøáÊª§ asyncio Áõ∏ÂÖ≥ÁöÑ RuntimeWarning
warnings.filterwarnings("ignore", category=RuntimeWarning, message=".*coroutine.*was never awaited.*")

from app.core.config import get_settings
from app.core.logging import get_logger
from datetime import datetime

# ÂÆâÂÖ®ÂØºÂÖ•Êï∞ÊçÆÂ∫ìÊ®°Âùó - Âª∂ËøüÂØºÂÖ•ÈÅøÂÖçmultiprocessingÈóÆÈ¢ò
DATABASE_AVAILABLE = False
db_manager = None
create_tables = None
get_db_monitor = None

def _safe_import_database():
    """ÂÆâÂÖ®ÂØºÂÖ•Êï∞ÊçÆÂ∫ìÊ®°Âùó"""
    global DATABASE_AVAILABLE, db_manager, create_tables, get_db_monitor
    
    if DATABASE_AVAILABLE:
        return True
        
    try:
        from app.core.database import create_tables as _create_tables, db_manager as _db_manager
        from app.utils.db_monitor import get_db_monitor as _get_db_monitor
        
        create_tables = _create_tables
        db_manager = _db_manager
        get_db_monitor = _get_db_monitor
        DATABASE_AVAILABLE = True
        
        logger.debug("‚úÖ Database module imported successfully")
        return True
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Database module import failed: {e}")
        logger.info("üí° Application will run in memory-only mode")
        DATABASE_AVAILABLE = False
        return False

# ÂØºÂÖ•ÊâÄÊúâÊ®°Âûã‰ª•Á°Æ‰øùË°®ÂÆö‰πâË¢´Ê≥®ÂÜå
import app.models  # Ëøô‰ºöÂØºÂÖ•ÊâÄÊúâÊ®°ÂûãÂÆö‰πâ

# ÂØºÂÖ•Ê†∏ÂøÉÊï¥ÂêàAPIË∑ØÁî± - ‰ºòÂÖàÁ∫ßÊúÄÈ´ò
from app.api.core_trading import router as core_trading_router

# ÂØºÂÖ•ÂéüÊúâAPIË∑ØÁî± - ‰øùÊåÅÂÖºÂÆπÊÄß
from app.api import (
    trend_router, monitor_router, notification_router,
    tradingview_router, strategy_router, ml_enhanced_router,
    backtest_router
)
from app.api.news import router as news_router
from app.api.kronos import router as kronos_router
from app.api.kronos_integrated import router as kronos_integrated_router
from app.api.funding_monitor import router as funding_monitor_router
from app.api.kronos_market_opportunities import router as kronos_market_opportunities_router
from app.api.kronos_advanced_opportunities import router as kronos_advanced_opportunities_router
from app.api.database import router as database_router
from app.api.http_pool import router as http_pool_router
from app.api.trading_pairs import router as trading_pairs_router
from app.api.unified_data import router as unified_data_router
from app.api.ml_config import router as ml_config_router
from app.api.enhanced_trading import router as enhanced_trading_router
from app.api.tradingview_scanner import router as tradingview_scanner_router
from app.api.tradingview_scheduler import router as tradingview_scheduler_router
from app.services.core.scheduler_service import SchedulerService
from app.services.ml.ml_enhanced_service import MLEnhancedService
from app.services.negative_funding_monitor_service import NegativeFundingMonitorService
from app.schemas.market_anomaly import AnomalyLevel

# Ëé∑ÂèñÈÖçÁΩÆÂíåÊó•Âøó
settings = get_settings()
logger = get_logger(__name__)

async def perform_startup_core_symbols_push():
    """ÂêØÂä®Êó∂ÊâßË°åÊ†∏ÂøÉÂ∏ÅÁßçÊìç‰ΩúÂª∫ËÆÆÊé®ÈÄÅ"""
    try:
        logger.info("üìä ÂºÄÂßãÂêØÂä®Êó∂Ê†∏ÂøÉÂ∏ÅÁßçÊìç‰ΩúÂª∫ËÆÆÊé®ÈÄÅ...")
        
        # ÂêØÂä®‰∫§ÊòìÊâÄÊúçÂä°ÁÆ°ÁêÜÂô®
        from app.services.exchanges.service_manager import start_exchange_services
        startup_result = await start_exchange_services()
        
        if startup_result['status'] == 'success':
            logger.info(f"‚úÖ ‰∫§ÊòìÊâÄÊúçÂä°ÂêØÂä®ÊàêÂäü: {startup_result['exchange']}")
        else:
            logger.error(f"‚ùå ‰∫§ÊòìÊâÄÊúçÂä°ÂêØÂä®Â§±Ë¥•: {startup_result.get('error')}")
            # ÁªßÁª≠ÊâßË°åÔºå‰ΩÜËÆ∞ÂΩïÈîôËØØ
        
        # ‰ΩøÁî®ÂÖ®Â±ÄÂçï‰æãËé∑ÂèñÊ†∏ÂøÉË∞ÉÂ∫¶ÊúçÂä°
        from app.services.core.core_scheduler_service import get_core_scheduler_service
        
        scheduler_service = await get_core_scheduler_service()
        
        # Á°Æ‰øùÊúçÂä°Â∑≤ÂàùÂßãÂåñ
        if not scheduler_service.trading_service:
            await scheduler_service._initialize_core_services()
        
        # ÊâßË°åÂêØÂä®Êó∂Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ
        success = await scheduler_service.run_startup_core_symbols_push()
        
        if success:
            logger.info("‚úÖ ÂêØÂä®Êó∂Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂÆåÊàê")
            return {
                "status": "success",
                "message": "ÂêØÂä®Êó∂Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂÆåÊàê",
                "timestamp": datetime.now().isoformat(),
                "push_type": "ÂêØÂä®Êé®ÈÄÅ"
            }
        else:
            logger.warning("‚ö†Ô∏è ÂêØÂä®Êó∂Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂ§±Ë¥•")
            return {
                "status": "failed", 
                "message": "ÂêØÂä®Êó∂Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂ§±Ë¥•",
                "timestamp": datetime.now().isoformat()
            }
            
    except Exception as e:
        logger.error(f"‚ùå ÂêØÂä®Êó∂Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂºÇÂ∏∏: {e}")
        return {
            "status": "error",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

async def perform_startup_trading_analysis():
    """ÂêØÂä®Êó∂ÊâßË°åÂÆåÊï¥ÁöÑ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÂíåÊé®ÈÄÅ - ‰øùÊåÅÂÖºÂÆπÊÄß"""
    try:
        logger.info("üéØ ÂêØÂä®‰∫§ÊòìÂàÜÊûê (ÂÖºÂÆπÊÄß‰øùÊåÅ) - Â∑≤Áî±Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ‰ªªÂä°Â§ÑÁêÜ")
        
        # ‰∏çÂÜçÈáçÂ§çË∞ÉÁî®Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÔºåÈÅøÂÖçÈáçÂ§çÊé®ÈÄÅ
        # Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂ∑≤ÁªèÂú® core_symbols_push ‰ªªÂä°‰∏≠Â§ÑÁêÜ
        
        return {
            "status": "success",
            "message": "‰∫§ÊòìÂàÜÊûê‰ªªÂä°Â∑≤Êï¥ÂêàÂà∞Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ‰∏≠",
            "analysis_results": [],
            "notifications_sent": 0,  # ÂÆûÈôÖÊé®ÈÄÅÁî± core_symbols_push ‰ªªÂä°Â§ÑÁêÜ
            "timestamp": datetime.now().isoformat()
        }
            
    except Exception as e:
        logger.error(f"‚ùå ÂêØÂä®‰∫§ÊòìÂàÜÊûêÂºÇÂ∏∏: {e}")
        return {
            "status": "error",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

# ‰øùÁïôÂéüÊúâÁöÑËØ¶ÁªÜÂàÜÊûêÂäüËÉΩ‰Ωú‰∏∫Â§áÁî®
async def perform_detailed_startup_trading_analysis():
    """ÂêØÂä®Êó∂ÊâßË°åËØ¶ÁªÜÁöÑ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÂíåÊé®ÈÄÅ - Â§áÁî®ÂäüËÉΩ"""
    try:
        logger.info("üéØ ÂºÄÂßãÂêØÂä®ËØ¶ÁªÜ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûê (Kronos+‰º†Áªü+MLÁªºÂêà)...")
        
        # ÂêØÂä®‰∫§ÊòìÊâÄÊúçÂä°ÁÆ°ÁêÜÂô®
        from app.services.exchanges.service_manager import start_exchange_services
        startup_result = await start_exchange_services()
        
        if startup_result['status'] == 'success':
            logger.info(f"‚úÖ ‰∫§ÊòìÊâÄÊúçÂä°ÂêØÂä®ÊàêÂäü: {startup_result['exchange']}")
        else:
            logger.error(f"‚ùå ‰∫§ÊòìÊâÄÊúçÂä°ÂêØÂä®Â§±Ë¥•: {startup_result.get('error')}")
            # ÁªßÁª≠ÊâßË°åÔºå‰ΩÜËÆ∞ÂΩïÈîôËØØ
        
        # ‰ΩøÁî®Â¢ûÂº∫ÁöÑÊ†∏ÂøÉ‰∫§ÊòìÊúçÂä°ÔºåÈõÜÊàêKronosÂàÜÊûê
        try:
            from app.services.trading.core_trading_service import get_core_trading_service, AnalysisType
            from app.services.notification.core_notification_service import get_core_notification_service
        except ImportError as e:
            logger.error(f"‚ùå ÂØºÂÖ•Ê†∏ÂøÉÊúçÂä°Â§±Ë¥•: {e}")
            return {
                "status": "error",
                "error": f"ÂØºÂÖ•Â§±Ë¥•: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }
        
        core_trading_service = await get_core_trading_service()
        await get_core_notification_service()
        
        # ‰∏ªË¶ÅÂàÜÊûêÁöÑ‰∫§ÊòìÂØπ
        major_symbols = ["BTC-USDT-SWAP", "ETH-USDT-SWAP", "SOL-USDT-SWAP", "DOGE-USDT-SWAP", "XRP-USDT-SWAP"]
        
        # ÊâßË°åÂÆåÊï¥ÁöÑ‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûê
        analysis_results = []
        notifications_sent = 0
        
        for symbol in major_symbols:
            try:
                logger.info(f"üîç ÁªºÂêàÂàÜÊûê {symbol} (Kronos+ÊäÄÊúØ+ML)...")
                
                # ‰ΩøÁî®ÈõÜÊàêÂàÜÊûê - ÂåÖÂê´Kronos„ÄÅ‰º†ÁªüÊäÄÊúØÂàÜÊûê„ÄÅMLÈ¢ÑÊµã
                trading_signal = await core_trading_service.analyze_symbol(
                    symbol=symbol,
                    analysis_type=AnalysisType.INTEGRATED,  # ‰ΩøÁî®ÁªºÂêàÂàÜÊûê
                    force_update=True
                )
                
                if not trading_signal:
                    logger.warning(f"‚ö†Ô∏è {symbol} ÂàÜÊûêÂ§±Ë¥•ÔºåË∑≥Ëøá")
                    continue
                
                # Êó•ÂÜÖÁü≠Á∫ø‰∫§Êòì‰ºòÂåñÔºöÂ§ßÂπÖÈôç‰ΩéÊé®ÈÄÅÈòàÂÄºÔºå‰∏ìÊ≥®5-15ÂàÜÈíüÁ∫ßÂà´‰ø°Âè∑
                # Ê£ÄÊü•ÊòØÂê¶ÊòØÁü≠Á∫ø‰ø°Âè∑ (ÈùûHOLD‰∏îÁΩÆ‰ø°Â∫¶>35% ÈÄÇÂêàÊó•ÂÜÖÁü≠Á∫ø‰∫§Êòì)
                if (trading_signal.final_action.upper() not in ['HOLD', 'ÊåÅÊúâ', 'ËßÇÊúõ', 'Á≠âÂæÖ'] and 
                    trading_signal.final_confidence > 0.35):
                    
                    # ËΩ¨Êç¢ÁΩÆ‰ø°Â∫¶Ê†ºÂºè
                    confidence_percent = trading_signal.final_confidence * 100 if trading_signal.final_confidence <= 1 else trading_signal.final_confidence
                    
                    analysis_results.append({
                        "symbol": symbol,
                        "action": trading_signal.final_action,
                        "confidence": confidence_percent,
                        "signal_strength": trading_signal.signal_strength.value if hasattr(trading_signal.signal_strength, 'value') else str(trading_signal.signal_strength),
                        "reasoning": trading_signal.reasoning,
                        "kronos_confidence": trading_signal.confidence_breakdown.get('kronos', 0) * 100,
                        "technical_confidence": trading_signal.confidence_breakdown.get('technical', 0) * 100,
                        "ml_confidence": trading_signal.confidence_breakdown.get('ml', 0) * 100,
                        "trading_signal": trading_signal
                    })
                    
                    # ‰ΩøÁî®Ê†∏ÂøÉ‰∫§ÊòìÊúçÂä°ÁöÑÊé®ÈÄÅÊñπÊ≥ï
                    try:
                        # Â¢ûÂº∫ÈÄöÁü•ÂÜÖÂÆπÔºåÂåÖÂê´ÊäÄÊúØÊåáÊ†áËØ¶ÊÉÖ
                        if hasattr(trading_signal, 'technical_result') and trading_signal.technical_result:
                            # ‰ªéÊäÄÊúØÂàÜÊûêÁªìÊûú‰∏≠ÊèêÂèñÊåáÊ†á‰ø°ÊÅØ
                            recommendation = trading_signal.technical_result.get('recommendation')
                            if recommendation and hasattr(recommendation, 'reasoning'):
                                # Â∞ÜÊäÄÊúØÊåáÊ†á‰ø°ÊÅØÊ∑ªÂä†Âà∞‰ø°Âè∑‰∏≠
                                trading_signal.technical_indicators = getattr(trading_signal, 'technical_indicators', {})
                                trading_signal.technical_indicators['analysis_details'] = recommendation.reasoning
                        
                        success = await core_trading_service.send_trading_signal_notification(trading_signal)
                        if success:
                            notifications_sent += 1
                            logger.info(f"‚úÖ ÂèëÈÄÅ {symbol} ÁªºÂêà‰∫§Êòì‰ø°Âè∑ÈÄöÁü•ÊàêÂäü")
                        else:
                            logger.warning(f"‚ùå ÂèëÈÄÅ {symbol} ÁªºÂêà‰∫§Êòì‰ø°Âè∑ÈÄöÁü•Â§±Ë¥•")
                        
                    except Exception as e:
                        logger.warning(f"ÂèëÈÄÅ {symbol} ‰∫§Êòì‰ø°Âè∑ÈÄöÁü•Â§±Ë¥•: {e}")
                
                else:
                    confidence_percent = trading_signal.final_confidence * 100 if trading_signal.final_confidence <= 1 else trading_signal.final_confidence
                    
                    # ËØ¶ÁªÜÊâìÂç∞ÊâÄÊúâÂàÜÊûêÁªìÊûúÔºåÂåÖÊã¨‰∏çÁ¨¶ÂêàÊé®ÈÄÅÊù°‰ª∂ÁöÑ
                    symbol_name = symbol.replace('-USDT-SWAP', '')
                    logger.info(f"üìä {symbol_name}: {trading_signal.final_action} (ÁªºÂêàÁΩÆ‰ø°Â∫¶: {confidence_percent:.1f}%) - ‰∏çÁ¨¶ÂêàÊé®ÈÄÅÊù°‰ª∂")
                    
                    # ÊâìÂç∞ÂêÑÊ®°ÂùóÁöÑËØ¶ÁªÜÂàÜÊûêÁªìÊûú
                    kronos_conf = trading_signal.confidence_breakdown.get('kronos', 0) * 100
                    technical_conf = trading_signal.confidence_breakdown.get('technical', 0) * 100
                    ml_conf = trading_signal.confidence_breakdown.get('ml', 0) * 100
                    
                    logger.info(f"   üîç ËØ¶ÁªÜÂàÜÊûê: ü§ñ Kronos: {kronos_conf:.1f}% | üìä ÊäÄÊúØ: {technical_conf:.1f}% | üß† ML: {ml_conf:.1f}%")
                    
                    # ÊâìÂç∞ÂÜ≥Á≠ñ‰æùÊçÆ
                    if hasattr(trading_signal, 'reasoning') and trading_signal.reasoning:
                        logger.info(f"   üí≠ ÂÜ≥Á≠ñ‰æùÊçÆ: {trading_signal.reasoning}")
                    
                    # ÊâìÂç∞ÂÖ≥ÈîÆÂõ†Á¥†
                    if hasattr(trading_signal, 'key_factors') and trading_signal.key_factors:
                        factors = trading_signal.key_factors[:3]
                        logger.info(f"   üìà ÂÖ≥ÈîÆÂõ†Á¥†: {', '.join(factors)}")
                    
                    # ÊâìÂç∞KronosÈ¢ÑÊµãËØ¶ÊÉÖÔºàÂ¶ÇÊûúÊúâÔºâ
                    if hasattr(trading_signal, 'kronos_result') and trading_signal.kronos_result:
                        kronos_result = trading_signal.kronos_result
                        if hasattr(kronos_result, 'kronos_prediction') and kronos_result.kronos_prediction:
                            pred = kronos_result.kronos_prediction
                            price_change = pred.price_change_pct * 100
                            logger.info(f"   ü§ñ KronosÈ¢ÑÊµã: ‰ª∑Ê†ºÂèòÂåñ {price_change:+.2f}%, ÁΩÆ‰ø°Â∫¶ {pred.confidence:.2f}")
                    
                    # ÊâìÂç∞ÊäÄÊúØÂàÜÊûêËØ¶ÊÉÖÔºàÂ¶ÇÊûúÊúâÔºâ
                    if hasattr(trading_signal, 'technical_result') and trading_signal.technical_result:
                        tech_result = trading_signal.technical_result
                        tech_action = tech_result.get('action', 'Unknown')
                        tech_confidence = tech_result.get('confidence', 0) * 100
                        logger.info(f"   üìä ÊäÄÊúØÂàÜÊûê: {tech_action} (ÁΩÆ‰ø°Â∫¶: {tech_confidence:.1f}%)")
                    
                    logger.info(f"   ‚ö†Ô∏è Êú™Êé®ÈÄÅÂéüÂõ†: ÁΩÆ‰ø°Â∫¶{confidence_percent:.1f}% < 35% Êàñ Ë°åÂä®‰∏∫ËßÇÊúõÁ±ªÂûã (Êó•ÂÜÖÁü≠Á∫øÈòàÂÄº)")
                    
            except Exception as e:
                logger.warning(f"‚ùå ÂàÜÊûê {symbol} Â§±Ë¥•: {e}")
                continue
        
        # ÊûÑÂª∫ËøîÂõûÁªìÊûú
        startup_results = {
            "status": "success",
            "total_analyzed": len(major_symbols),
            "successful_analyses": len(analysis_results),
            "notifications_sent": notifications_sent,
            "strong_signals": analysis_results,
            "analysis_method": "core_trading_service_with_kronos_integration"
        }
        
        # ËÆ∞ÂΩïÂàÜÊûêÁªìÊûú
        logger.info(f"‚úÖ ÂêØÂä®ÂÆåÊï¥‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÂÆåÊàê (Kronos+ÊäÄÊúØ+ML):")
        logger.info(f"   üìä ÂàÜÊûê‰∫§ÊòìÂØπ: {len(major_symbols)} ‰∏™")
        logger.info(f"   üéØ ÂèëÁé∞Âº∫‰ø°Âè∑: {len(analysis_results)} ‰∏™")
        logger.info(f"   üì¢ ÈÄöÁü•ÂèëÈÄÅ: {notifications_sent} Êù°")
        logger.info(f"   üîß ÂàÜÊûêÊñπÊ≥ï: Kronos AI + Â¢ûÂº∫ÊäÄÊúØÂàÜÊûê + Êú∫Âô®Â≠¶‰π†")
        
        # ËÆ∞ÂΩïÂº∫‰ø°Âè∑ËØ¶ÊÉÖ
        for i, signal in enumerate(analysis_results[:3], 1):
            symbol = signal["symbol"].replace('-USDT-SWAP', '')
            action = signal["action"]
            confidence = signal["confidence"]
            signal_strength = signal["signal_strength"]
            kronos_conf = signal.get('kronos_confidence', 0)
            technical_conf = signal.get('technical_confidence', 0)
            ml_conf = signal.get('ml_confidence', 0)
            
            logger.info(f"   {i}. üéØ {symbol}: {action} (ÁªºÂêà: {confidence:.1f}%)")
            logger.info(f"      ü§ñ Kronos: {kronos_conf:.1f}% | üìä ÊäÄÊúØ: {technical_conf:.1f}% | üß† ML: {ml_conf:.1f}%")
            logger.info(f"      üî• ‰ø°Âè∑Âº∫Â∫¶: {signal_strength}")
            
            # ÊòæÁ§∫ÊäÄÊúØÊåáÊ†á‰∫ÆÁÇπ
            if len(signal.get('key_factors', [])) > 0:
                factors = signal['key_factors'][:3]
                logger.info(f"      üìà ÂÖ≥ÈîÆÂõ†Á¥†: {', '.join(factors)}")
        
        return startup_results
        
    except Exception as e:
        logger.error(f"‚ùå ÂêØÂä®ÂÆåÊï¥‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÂ§±Ë¥•: {e}")
        return {"status": "error", "error": str(e)}

async def send_startup_summary_notification(app_state, successful_tasks: int, failed_tasks: int):
    """ÂèëÈÄÅÂêØÂä®ÂÆåÊàêÊëòË¶ÅÈÄöÁü•"""
    try:
        from app.services.notification.core_notification_service import get_core_notification_service
        notification_service = await get_core_notification_service()
        
        # Êî∂ÈõÜÂêÑ‰ªªÂä°ÁªìÊûú
        trading_result = getattr(app_state, 'startup_trading_analysis_results', {})
        funding_result = getattr(app_state, 'startup_funding_analysis_results', {})
        getattr(app_state, 'startup_news_analysis_results', {})
        kronos_result = getattr(app_state, 'startup_kronos_market_scan_results', {})
        
        # ÊûÑÂª∫ÊëòË¶ÅÊ∂àÊÅØ
        message = f"üöÄ **‰∫§ÊòìÂàÜÊûêÂ∑•ÂÖ∑ÂêØÂä®ÂÆåÊàê**\n\n"
        message += f"üìä ‰ªªÂä°ÊâßË°å: {successful_tasks} ÊàêÂäü, {failed_tasks} Â§±Ë¥•\n\n"
        
        # ÂÆåÊï¥‰∫§ÊòìÂÜ≥Á≠ñÂàÜÊûêÁªìÊûú
        if trading_result.get("status") == "success":
            strong_signals = len(trading_result.get("strong_signals", []))
            notifications = trading_result.get("notifications_sent", 0)
            message += f"üéØ ÂÆåÊï¥‰∫§ÊòìÂàÜÊûê: {strong_signals} ‰∏™Âº∫‰ø°Âè∑, {notifications} Êù°ÈÄöÁü•\n"
        
        # Ë¥üË¥πÁéáÂàÜÊûêÁªìÊûú
        if funding_result.get("status") == "success":
            opportunities = funding_result.get("opportunities_count", 0)
            message += f"üí∞ Ë¥üË¥πÁéáÊú∫‰ºö: {opportunities} ‰∏™Â•óÂà©Êú∫‰ºö\n"
        
        # Â∏ÇÂú∫ÂºÇÂ∏∏ÂàÜÊûêÁªìÊûú
        market_anomaly_result = task_results.get("market_anomaly_analysis", {})
        if market_anomaly_result.get("status") == "success":
            anomalies_found = market_anomaly_result.get("anomalies_found", 0)
            recommended_count = market_anomaly_result.get("recommended_count", 0)
            message += f"üö® Â∏ÇÂú∫ÂºÇÂ∏∏: {anomalies_found} ‰∏™ÂºÇÂ∏∏, {recommended_count} ‰∏™Êé®Ëçê\n"
        

        
        # KronosÂ∏ÇÂú∫Êâ´Êèè - Â∑≤Êï¥ÂêàÂà∞Ê†∏ÂøÉ‰∫§ÊòìÂàÜÊûê‰∏≠
        if kronos_result.get("status") == "success":
            kronos_opportunities = kronos_result.get("summary", {}).get("total_strong_opportunities", 0)
            message += f"ü§ñ KronosÊâ´Êèè: {kronos_opportunities} ‰∏™AIÊú∫‰ºö (Â∑≤Êï¥Âêà)\n"
        else:
            message += f"ü§ñ KronosÊâ´Êèè: Â∑≤Êï¥ÂêàÂà∞Ê†∏ÂøÉÂàÜÊûê\n"
        
        message += f"\n‚è∞ ÂêØÂä®Êó∂Èó¥: {datetime.now().strftime('%H:%M:%S')}"
        message += f"\nüîÑ Á≥ªÁªüÂ∑≤Â∞±Áª™ÔºåÂºÄÂßãÁõëÊéßÂ∏ÇÂú∫..."
        
        # Á°ÆÂÆöÈÄöÁü•‰ºòÂÖàÁ∫ß
        total_signals = (
            len(trading_result.get("strong_signals", [])) +
            funding_result.get("opportunities_count", 0) +
            kronos_result.get("summary", {}).get("total_strong_opportunities", 0) +
            market_anomaly_result.get("recommended_count", 0)
        )
        
        priority = "high" if total_signals > 0 else "medium" if failed_tasks == 0 else "low"
        
        from app.services.notification.core_notification_service import NotificationContent, NotificationType, NotificationPriority
        
        # ËΩ¨Êç¢‰ºòÂÖàÁ∫ßÂ≠óÁ¨¶‰∏≤‰∏∫Êûö‰∏æ
        priority_map = {
            "high": NotificationPriority.HIGH,
            "medium": NotificationPriority.NORMAL,
            "low": NotificationPriority.LOW
        }
        
        content = NotificationContent(
            type=NotificationType.SYSTEM_ALERT,
            priority=priority_map.get(priority, NotificationPriority.NORMAL),
            title=f"üöÄ Á≥ªÁªüÂêØÂä®ÂÆåÊàê ({successful_tasks}/{successful_tasks + failed_tasks})",
            message=message,
            metadata={
                'successful_tasks': successful_tasks,
                'failed_tasks': failed_tasks,
                'total_signals': total_signals
            }
        )
        
        await notification_service.send_notification(content)
        
        logger.info(f"‚úÖ ÂêØÂä®ÊëòË¶ÅÈÄöÁü•Â∑≤ÂèëÈÄÅ (‰ºòÂÖàÁ∫ß: {priority})")
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è ÂèëÈÄÅÂêØÂä®ÊëòË¶ÅÈÄöÁü•Â§±Ë¥•: {e}")

async def perform_startup_funding_analysis():
    """ÂêØÂä®Êó∂ÊâßË°åË¥üË¥πÁéáÂàÜÊûêÂíåÊé®ÈÄÅ"""
    try:
        logger.info("üí∞ ÂºÄÂßãË¥üË¥πÁéáÂêÉÂà©ÊÅØÊú∫‰ºöÂàÜÊûê...")
        
        # ÂàõÂª∫Ë¥üË¥πÁéáÁõëÊéßÊúçÂä°
        funding_monitor = NegativeFundingMonitorService()
        
        # ÊâßË°åÂ¢ûÂº∫ÁâàÁõëÊéßÊ£ÄÊü•ÔºàÂåÖÂê´ËØ¶ÁªÜÁöÑ‰ª∑Ê†ºÈ¢ÑÊµãÂíå‰ªì‰ΩçÂª∫ËÆÆÔºâ
        result = await funding_monitor.run_monitoring_cycle(enable_enhanced_analysis=True)
        
        if result['success']:
            opportunities = result['opportunities']
            logger.info(f"‚úÖ Ë¥üË¥πÁéáÂàÜÊûêÂÆåÊàê: ÂèëÁé∞ {len(opportunities)} ‰∏™ÂêÉÂà©ÊÅØÊú∫‰ºö")
            
            if opportunities:
                # ËÆ∞ÂΩïÊúÄ‰Ω≥Êú∫‰ºö
                best = opportunities[0]
                symbol_name = best['symbol'].replace('-USDT-SWAP', '')
                daily_rate = best['daily_rate_percent']
                daily_income = best['daily_income_10k']
                
                logger.info(f"üéØ ÊúÄ‰Ω≥Êú∫‰ºö: {symbol_name}")
                logger.info(f"   üí∞ Êó•ÂåñÊî∂Áõä: {daily_rate:.3f}%")
                logger.info(f"   üíµ 1‰∏áUÊó•Êî∂Áõä: ${daily_income:.2f}")
                logger.info(f"   üìä ËØÑÂàÜ: {best['score']}/100")
                
                # ËÆ∞ÂΩïÂâç3‰∏™Êú∫‰ºö
                for i, opp in enumerate(opportunities[:3], 1):
                    symbol = opp['symbol'].replace('-USDT-SWAP', '')
                    rate = opp['funding_rate_percent']
                    daily = opp['daily_rate_percent']
                    logger.info(f"   {i}. {symbol}: {rate:.3f}% ‚Üí Êó•Âåñ {daily:.3f}%")
            else:
                logger.info("üìä ÂΩìÂâçÂ∏ÇÂú∫Êó†Ë¥üË¥πÁéáÊú∫‰ºö")
            
            return {
                "status": "success",
                "opportunities_count": len(opportunities),
                "opportunities": opportunities[:5],  # ËøîÂõûÂâç5‰∏™
                "analysis_time": result['analysis_time'],
                "duration": result['duration_seconds']
            }
        else:
            error_msg = result.get('error', 'Êú™Áü•ÈîôËØØ')
            logger.error(f"‚ùå Ë¥üË¥πÁéáÂàÜÊûêÂ§±Ë¥•: {error_msg}")
            return {"status": "error", "error": error_msg}
            
    except Exception as e:
        logger.error(f"‚ùå Ë¥üË¥πÁéáÂàÜÊûêÂºÇÂ∏∏: {e}")
        return {"status": "error", "error": str(e)}

async def perform_startup_market_anomaly_analysis():
    """ÂêØÂä®Êó∂ÊâßË°åÂ∏ÇÂú∫ÂºÇÂ∏∏ÂàÜÊûêÂíåÊé®ÈÄÅ"""
    try:
        logger.info("üö® ÂºÄÂßãÂ∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÂàÜÊûê...")
        
        from app.services.market_anomaly_monitor_service import get_market_anomaly_service
        
        # Ëé∑ÂèñÂ∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÊúçÂä°
        market_anomaly_service = await get_market_anomaly_service()
        
        # ÊâßË°åÁõëÊéßÂë®Êúü
        result = await market_anomaly_service.run_monitoring_cycle()
        
        if result['success']:
            anomalies_found = result['anomalies_found']
            recommended_count = result['recommended_count']
            
            logger.info(f"‚úÖ Â∏ÇÂú∫ÂºÇÂ∏∏ÂàÜÊûêÂÆåÊàê: ÂèëÁé∞ {anomalies_found} ‰∏™ÂºÇÂ∏∏")
            logger.info(f"‚≠ê Êé®ËçêÂÖ≥Ê≥®: {recommended_count} ‰∏™Â∏ÅÁßç")
            
            if recommended_count > 0:
                logger.info("üèÜ ÂèëÁé∞Êé®ËçêÁöÑÂºÇÂ∏∏Êú∫‰ºöÔºåÂ∑≤ÂèëÈÄÅÈÄöÁü•")
            else:
                logger.info("üìä ÂΩìÂâçÂ∏ÇÂú∫Êó†ÊòæËëóÂºÇÂ∏∏")
            
            return {
                "status": "success",
                "anomalies_found": anomalies_found,
                "recommended_count": recommended_count,
                "timestamp": result['timestamp']
            }
        else:
            error_msg = result.get('error', 'Êú™Áü•ÈîôËØØ')
            logger.error(f"‚ùå Â∏ÇÂú∫ÂºÇÂ∏∏ÂàÜÊûêÂ§±Ë¥•: {error_msg}")
            return {"status": "error", "error": error_msg}
            
    except Exception as e:
        logger.error(f"‚ùå Â∏ÇÂú∫ÂºÇÂ∏∏ÂàÜÊûêÂºÇÂ∏∏: {e}")
        return {"status": "error", "error": str(e)}

async def perform_startup_grid_trading_analysis():
    """ÂêØÂä®Êó∂ÊâßË°åÁΩëÊ†º‰∫§ÊòìÊú∫‰ºöÂàÜÊûêÂíåÊé®ÈÄÅ"""
    try:
        logger.info("üî≤ ÂºÄÂßãÁΩëÊ†º‰∫§ÊòìÊú∫‰ºöÂàÜÊûê...")
        
        from app.services.core.grid_scheduler_extension import get_grid_scheduler_extension
        
        # Ëé∑ÂèñÁΩëÊ†º‰∫§ÊòìË∞ÉÂ∫¶Âô®Êâ©Â±ï
        grid_extension = await get_grid_scheduler_extension()
        
        # ÊâßË°åÂêØÂä®Êó∂ÁΩëÊ†º‰∫§ÊòìÊé®Ëçê
        success = await grid_extension.run_startup_grid_recommendations()
        
        if success:
            logger.info("‚úÖ ÁΩëÊ†º‰∫§ÊòìÊú∫‰ºöÂàÜÊûêÂÆåÊàê")
            return {
                "status": "success",
                "message": "ÁΩëÊ†º‰∫§ÊòìÊú∫‰ºöÂàÜÊûêÂÆåÊàê",
                "timestamp": datetime.now().isoformat()
            }
        else:
            logger.warning("‚ö†Ô∏è ÁΩëÊ†º‰∫§ÊòìÊú∫‰ºöÂàÜÊûêÂ§±Ë¥•")
            return {
                "status": "warning",
                "message": "ÁΩëÊ†º‰∫§ÊòìÊú∫‰ºöÂàÜÊûêÂ§±Ë¥•",
                "timestamp": datetime.now().isoformat()
            }
            
    except Exception as e:
        logger.error(f"‚ùå ÁΩëÊ†º‰∫§ÊòìÊú∫‰ºöÂàÜÊûêÂºÇÂ∏∏: {e}")
        return {"status": "error", "error": str(e)}

async def perform_startup_news_analysis():
    """ÂêØÂä®Êó∂ÊâßË°åÊñ∞ÈóªÂàÜÊûêÂíåÊé®ÈÄÅ"""
    try:
        logger.info("üì∞ ÂºÄÂßãÂêØÂä®Êñ∞ÈóªÂàÜÊûê...")
        
        from app.services.data.news_monitor_service import get_news_monitor_service
        
        # Ëé∑ÂèñÊñ∞ÈóªÁõëÊéßÊúçÂä°
        news_monitor = await get_news_monitor_service()
        
        # ÊâßË°å‰∏ÄÊ¨°ÁõëÊéßÂë®Êúü
        result = await news_monitor.run_monitoring_cycle()
        
        if result['status'] == 'success':
            news_count = result.get('news_count', 0)
            analysis_count = result.get('analysis_count', 0)
            notifications_sent = result.get('notifications_sent', 0)
            
            logger.info(f"‚úÖ ÂêØÂä®Êñ∞ÈóªÂàÜÊûêÂÆåÊàê:")
            logger.info(f"   üì∞ Ëé∑ÂèñÊñ∞Èóª: {news_count} Êù°")
            logger.info(f"   üîç ÂàÜÊûêÊñ∞Èóª: {analysis_count} Êù°")
            logger.info(f"   üì¢ ÂèëÈÄÅÈÄöÁü•: {notifications_sent} Êù°")
            
            return {
                "status": "success",
                "news_count": news_count,
                "analysis_count": analysis_count,
                "notifications_sent": notifications_sent,
                "duration": result.get('duration_seconds', 0),
                "message": result.get('message', 'ÂàÜÊûêÂÆåÊàê')
            }
        elif result['status'] == 'disabled':
            logger.info("üì¥ Êñ∞ÈóªÂàÜÊûêÂ∑≤Á¶ÅÁî®")
            return {"status": "disabled", "message": "Êñ∞ÈóªÂàÜÊûêÂ∑≤Á¶ÅÁî®"}
        else:
            error_msg = result.get('message', 'Êú™Áü•ÈîôËØØ')
            logger.error(f"‚ùå ÂêØÂä®Êñ∞ÈóªÂàÜÊûêÂ§±Ë¥•: {error_msg}")
            return {"status": "error", "error": error_msg}
            
    except Exception as e:
        logger.error(f"‚ùå ÂêØÂä®Êñ∞ÈóªÂàÜÊûêÂºÇÂ∏∏: {e}")
        return {"status": "error", "error": str(e)}

async def perform_startup_ml_analysis(ml_service: MLEnhancedService):
    """ÂêØÂä®Êó∂ÊâßË°åMLÂàÜÊûêÂíåÊé®ÈÄÅÔºàÂèØÈÄâÔºâ"""
    try:
        logger.info("ü§ñ ÂºÄÂßãMLÂ¢ûÂº∫ÂàÜÊûê...")
        # MLÈÄöÁü•ÂäüËÉΩÂ∑≤Êï¥ÂêàÂà∞Ê†∏ÂøÉÈÄöÁü•ÊúçÂä°‰∏≠
        from app.services.notification.core_notification_service import get_core_notification_service
        notification_service = await get_core_notification_service()
        
        # ÂØºÂÖ•ÂºÇÂ∏∏Áä∂ÊÄÅÁÆ°ÁêÜÂô®
        from app.services.ml.anomaly_state_manager import anomaly_state_manager
        
        # Ê∏ÖÁêÜËøáÊúüÁöÑÂºÇÂ∏∏ËÆ∞ÂΩï
        anomaly_state_manager.cleanup_old_records(max_age_hours=24)
        
        # ÂàÜÊûêÈÖçÁΩÆ‰∏≠ÁöÑÊâÄÊúâ‰∫§ÊòìÂØπ
        symbols_to_analyze = settings.monitored_symbols
        all_detected_anomalies = []  # Êî∂ÈõÜÊâÄÊúâÂ∏ÅÁßçÊ£ÄÊµãÂà∞ÁöÑÂºÇÂ∏∏
        
        for symbol in symbols_to_analyze:
            try:
                logger.info(f"üîç MLÂàÜÊûê {symbol}...")
                
                # 1. ÊâßË°åÈ¢ÑÊµãÂàÜÊûê
                prediction = await ml_service.predict_signal(symbol)
                logger.info(f"üìä {symbol} MLÈ¢ÑÊµã: {prediction.signal.value} (ÁΩÆ‰ø°Â∫¶: {prediction.confidence:.3f})")
                
                # Èôç‰ΩéMLÈ¢ÑÊµãÊé®ÈÄÅÈó®Êßõ
                if (prediction.signal.value in ['buy', 'sell'] and prediction.confidence > 0.6) or \
                   prediction.signal.value in ['strong_buy', 'strong_sell'] or \
                   (prediction.signal.value == 'hold' and prediction.confidence > 0.8):
                    # ‰ΩøÁî®Ê†∏ÂøÉÈÄöÁü•ÊúçÂä°ÂèëÈÄÅMLÈ¢ÑÊµãÈÄöÁü•
                    await notification_service.send_ml_prediction_notification({
                        'symbol': symbol,
                        'signal': prediction.signal.value,
                        'confidence': prediction.confidence,
                        'timestamp': datetime.now()
                    })
                    logger.info(f"üì¢ Â∑≤ÂèëÈÄÅ {symbol} MLÈ¢ÑÊµãÈÄöÁü•")
                
                # 2. ÊâßË°åÂºÇÂ∏∏Ê£ÄÊµã
                anomalies = await ml_service.detect_anomalies(symbol)
                if anomalies:
                    logger.info(f"‚ö†Ô∏è {symbol} Ê£ÄÊµãÂà∞ {len(anomalies)} ‰∏™ÂºÇÂ∏∏")
                    # ËøáÊª§Âá∫‰∏•ÈáçÁ®ãÂ∫¶Ë∂≥Â§üÁöÑÂºÇÂ∏∏
                    significant_anomalies = [
                        a for a in anomalies 
                        if a.severity > 0.5  # ‰∏•ÈáçÁ®ãÂ∫¶Â§ß‰∫é50%
                    ]
                    
                    if significant_anomalies:
                        all_detected_anomalies.extend(significant_anomalies)
                        logger.info(f"üìä {symbol} ÂèëÁé∞ {len(significant_anomalies)} ‰∏™ÊòæËëóÂºÇÂ∏∏")
                
            except Exception as e:
                logger.warning(f"‚ùå MLÂàÜÊûê {symbol} Â§±Ë¥•: {e}")
                continue
        
        # 3. ‰ΩøÁî®Áä∂ÊÄÅÁÆ°ÁêÜÂô®ËøáÊª§Âá∫ÁúüÊ≠£ÁöÑÊñ∞ÂºÇÂ∏∏
        if all_detected_anomalies:
            new_anomalies = anomaly_state_manager.filter_new_anomalies(all_detected_anomalies)
            
            if new_anomalies:
                # Êåâ‰∏•ÈáçÁ®ãÂ∫¶ÊéíÂ∫èÔºåÂè™Êé®ÈÄÅÊúÄ‰∏•ÈáçÁöÑÂâç5‰∏™
                new_anomalies.sort(key=lambda x: x.severity, reverse=True)
                top_anomalies = new_anomalies[:5]
                
                # ‰ΩøÁî®Ê†∏ÂøÉÈÄöÁü•ÊúçÂä°ÂèëÈÄÅÂºÇÂ∏∏Ë≠¶Êä•
                await notification_service.send_anomaly_notification({
                    'anomalies': [{'symbol': a.symbol, 'severity': a.severity, 'description': str(a)} for a in top_anomalies],
                    'count': len(top_anomalies),
                    'timestamp': datetime.now()
                })
                logger.info(f"üì¢ Â∑≤ÂèëÈÄÅ {len(top_anomalies)} ‰∏™Êñ∞ÂºÇÂ∏∏Ë≠¶Êä•ÔºåÊ∂âÂèäÂ∏ÅÁßç: {list(set(a.symbol for a in top_anomalies))}")
            else:
                logger.info("‚úÖ ÊâÄÊúâÊ£ÄÊµãÂà∞ÁöÑÂºÇÂ∏∏ÈÉΩÂ∑≤ÈÄöÁü•ËøáÔºåË∑≥ËøáÊé®ÈÄÅ")
        else:
            logger.info("‚úÖ Êú™Ê£ÄÊµãÂà∞‰ªª‰ΩïÂºÇÂ∏∏")
        
        # 4. ËæìÂá∫ÂºÇÂ∏∏ÁªüËÆ°‰ø°ÊÅØ
        stats = anomaly_state_manager.get_anomaly_stats()
        if stats:
            logger.info(f"üìä ÂºÇÂ∏∏ÁªüËÆ°: {stats}")
        
        logger.info("‚úÖ MLÂ¢ûÂº∫ÂàÜÊûêÂÆåÊàê")
        
    except Exception as e:
        logger.error(f"‚ùå MLÂ¢ûÂº∫ÂàÜÊûêÂ§±Ë¥•: {e}")

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Â∫îÁî®ÁîüÂëΩÂë®ÊúüÁÆ°ÁêÜ"""
    # ÂêØÂä®Êó∂ÊâßË°å
    logger.info("üöÄ Starting Python Trading Analysis Tool...")
    
    # Â≠òÂÇ®ÈúÄË¶ÅÊ∏ÖÁêÜÁöÑËµÑÊ∫ê
    
    try:
        # ÂÆâÂÖ®ÂØºÂÖ•Êï∞ÊçÆÂ∫ìÊ®°Âùó
        database_imported = _safe_import_database()
        
        if not database_imported:
            logger.warning("‚ö†Ô∏è Database module not available - running in memory mode")
            app.state.database_available = False
        else:
            # Â∞ùËØïÂàõÂª∫Êï∞ÊçÆÂ∫ìË°® - ÂÖÅËÆ∏Â§±Ë¥•
            try:
                if create_tables:
                    create_tables()
                    logger.info("‚úÖ Database tables created successfully")
                else:
                    logger.warning("‚ö†Ô∏è create_tables function not available")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Database table creation failed: {e}")
                logger.info("üí° Application will continue without database persistence")
            
            # ÊµãËØïÊï∞ÊçÆÂ∫ìËøûÊé•ÂíåËøûÊé•Ê±† - ÂÖÅËÆ∏Âú®Êï∞ÊçÆÂ∫ì‰∏çÂèØÁî®Êó∂ÁªßÁª≠ËøêË°å
            try:
                # È™åËØÅÊï∞ÊçÆÂ∫ìÁÆ°ÁêÜÂô®ÊòØÂê¶ÂèØÁî®
                logger.debug("üîç ÂºÄÂßãÊï∞ÊçÆÂ∫ìÂÅ•Â∫∑Ê£ÄÊü•...")
                
                # Ê£ÄÊü• db_manager ÊòØÂê¶Â∑≤Ê≠£Á°ÆÂØºÂÖ•ÂíåÂàùÂßãÂåñ
                if db_manager is None:
                    logger.warning("‚ö†Ô∏è Database manager is None - running in memory mode")
                    app.state.database_available = False
                else:
                    logger.debug("‚úÖ Database manager is available, performing health check...")
                    if get_db_monitor:
                        db_monitor = get_db_monitor()
                        
                        if db_manager.health_check():
                            logger.info("‚úÖ Database connection healthy")
                            
                            # ÊòæÁ§∫ËøûÊé•Ê±†Áä∂ÊÄÅ
                            pool_stats = db_monitor.get_pool_stats()
                            logger.info(f"üìä Connection pool stats: {pool_stats}")
                            
                            app.state.database_available = True
                            app.state.db_monitor = db_monitor
                        else:
                            logger.warning("‚ö†Ô∏è Database connection failed - running in memory mode")
                            app.state.database_available = False
                    else:
                        logger.warning("‚ö†Ô∏è get_db_monitor function not available - running in memory mode")
                        app.state.database_available = False
                        
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Database health check failed: {e} - running in memory mode")
                app.state.database_available = False
        
        # ÂêØÂä®Áªü‰∏ÄË∞ÉÂ∫¶Âô®ÔºàÂåÖÂê´Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ‰ªªÂä°Ôºâ
        scheduler = SchedulerService()
        await scheduler.start()
        logger.info("‚úÖ Áªü‰∏ÄË∞ÉÂ∫¶Âô®ÂêØÂä®ÊàêÂäüÔºàÂåÖÂê´Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ‰ªªÂä°Ôºâ")
        
        if settings.kronos_config.get('enable_kronos_prediction', False):
            logger.info("‚úÖ KronosÈ¢ÑÊµãÂ∑≤ÂêØÁî®ÔºåÊ†∏ÂøÉ‰ø°Âè∑ÂàÜÊûêÁî±Ë∞ÉÂ∫¶Âô®Áªü‰∏ÄÁÆ°ÁêÜ")
        else:
            logger.info("üì¥ KronosÈ¢ÑÊµãÂ∑≤Á¶ÅÁî®")
        
        # Ê∑ªÂä†Ë¥üË¥πÁéáÁõëÊéßÂÆöÊó∂‰ªªÂä°
        funding_monitor = NegativeFundingMonitorService()
        
        # ÊØè60ÂàÜÈíüÊ£ÄÊü•‰∏ÄÊ¨°Ë¥üË¥πÁéáÊú∫‰ºöÔºà‰ΩøÁî®Â¢ûÂº∫ÁâàÂàÜÊûêÔºâ
        async def funding_monitor_task():
            """Ë¥üË¥πÁéáÁõëÊéß‰ªªÂä°ÂåÖË£ÖÂô®"""
            try:
                logger.debug("üîÑ ÂºÄÂßãÊâßË°åË¥üË¥πÁéáÁõëÊéß‰ªªÂä°...")
                result = await funding_monitor.run_monitoring_cycle(enable_enhanced_analysis=True)
                if result.get('success'):
                    logger.debug("‚úÖ Ë¥üË¥πÁéáÁõëÊéß‰ªªÂä°ÊâßË°åÊàêÂäü")
                else:
                    logger.warning(f"‚ö†Ô∏è Ë¥üË¥πÁéáÁõëÊéß‰ªªÂä°ÊâßË°åÂºÇÂ∏∏: {result.get('error', 'Êú™Áü•ÈîôËØØ')}")
            except Exception as e:
                logger.error(f"‚ùå Ë¥üË¥πÁéáÁõëÊéß‰ªªÂä°ÊâßË°åÂ§±Ë¥•: {e}")
        
        scheduler.add_job(
            funding_monitor_task,
            'interval',
            minutes=60,
            id='negative_funding_monitor',
            name='Ë¥üË¥πÁéáÂêÉÂà©ÊÅØÊú∫‰ºöÁõëÊéßÔºàÂ¢ûÂº∫ÁâàÔºâ',
            max_instances=1  # Á°Æ‰øùÂêåÊó∂Âè™Êúâ‰∏Ä‰∏™ÂÆû‰æãËøêË°å
        )
        logger.info("‚úÖ Negative funding rate monitor scheduled")
        

        
        # Â∞ÜË¥üË¥πÁéáÁõëÊéßÊúçÂä°Â≠òÂÇ®Âà∞Â∫îÁî®Áä∂ÊÄÅ
        app.state.funding_monitor = funding_monitor
        
        # Ê∑ªÂä†Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÂÆöÊó∂‰ªªÂä°
        from app.services.market_anomaly_monitor_service import get_market_anomaly_service
        
        market_anomaly_service = await get_market_anomaly_service()
        
        # ÊØè60ÂàÜÈíüÊ£ÄÊü•‰∏ÄÊ¨°Â∏ÇÂú∫ÂºÇÂ∏∏
        async def market_anomaly_task():
            """Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéß‰ªªÂä°ÂåÖË£ÖÂô®"""
            try:
                logger.debug("üîÑ ÂºÄÂßãÊâßË°åÂ∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéß‰ªªÂä°...")
                result = await market_anomaly_service.run_monitoring_cycle()
                if result.get('success'):
                    anomalies_count = result.get('anomalies_found', 0)
                    recommended_count = result.get('recommended_count', 0)
                    logger.debug(f"‚úÖ Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéß‰ªªÂä°ÊâßË°åÊàêÂäü: {anomalies_count}‰∏™ÂºÇÂ∏∏, {recommended_count}‰∏™Êé®Ëçê")
                else:
                    logger.warning(f"‚ö†Ô∏è Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéß‰ªªÂä°ÊâßË°åÂºÇÂ∏∏: {result.get('error', 'Êú™Áü•ÈîôËØØ')}")
            except Exception as e:
                logger.error(f"‚ùå Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéß‰ªªÂä°ÊâßË°åÂ§±Ë¥•: {e}")
        
        scheduler.add_job(
            market_anomaly_task,
            'interval',
            minutes=60,
            id='market_anomaly_monitor',
            name='Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÔºàÊ≥¢Âä®Áéá+‰∫§ÊòìÈáè+ÊåÅ‰ªìÈáèÔºâ',
            max_instances=1  # Á°Æ‰øùÂêåÊó∂Âè™Êúâ‰∏Ä‰∏™ÂÆû‰æãËøêË°å
        )
        logger.info("‚úÖ Market anomaly monitor scheduled")
        
        # Â∞ÜÂ∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÊúçÂä°Â≠òÂÇ®Âà∞Â∫îÁî®Áä∂ÊÄÅ
        app.state.market_anomaly_service = market_anomaly_service
        
        # Ê∑ªÂä†TradingViewÊâ´ÊèèÂô®ÂÆöÊó∂‰ªªÂä°
        from app.services.core.tradingview_scheduler_service import get_tradingview_scheduler_service
        
        tradingview_scheduler_service = await get_tradingview_scheduler_service()
        
        # ÂêØÂä®Êó∂Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°TradingViewÊâ´Êèè
        try:
            logger.info("üìä ÂêØÂä®Êó∂Á´ãÂç≥ÊâßË°åTradingViewÂº∫ÂäøÂ∏ÅÁßçÊâ´Êèè...")
            startup_scan_result = await tradingview_scheduler_service.scan_and_notify()
            app.state.startup_tradingview_scan = startup_scan_result
            
            if startup_scan_result.get("status") == "success":
                symbols_count = startup_scan_result.get("symbols_count", 0)
                logger.info(f"‚úÖ ÂêØÂä®TradingViewÊâ´ÊèèÂÆåÊàê: ÂèëÁé∞ {symbols_count} ‰∏™Âº∫ÂäøÂ∏ÅÁßç")
            else:
                logger.warning(f"‚ö†Ô∏è ÂêØÂä®TradingViewÊâ´ÊèèÂºÇÂ∏∏: {startup_scan_result.get('error', 'Êú™Áü•')}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è ÂêØÂä®TradingViewÊâ´ÊèèÂ§±Ë¥•: {e}")
            app.state.startup_tradingview_scan = {"status": "error", "error": str(e)}
        
        # ÊØè60ÂàÜÈíüÊâßË°å‰∏ÄÊ¨°TradingViewÊâ´Êèè
        scheduler.add_job(
            tradingview_scheduler_service.scan_and_notify,
            'interval',
            minutes=60,
            id='tradingview_scanner',
            name='TradingViewÂº∫ÂäøÂ∏ÅÁßçÊâ´Êèè',
            max_instances=1  # Á°Æ‰øùÂêåÊó∂Âè™Êúâ‰∏Ä‰∏™ÂÆû‰æãËøêË°å
        )
        logger.info("‚úÖ TradingViewÊâ´ÊèèÂô®ÂÆöÊó∂‰ªªÂä°Â∑≤ÂêØÂä® (ÊØè60ÂàÜÈíü)")
        
        # Â∞ÜÊúçÂä°Â≠òÂÇ®Âà∞Â∫îÁî®Áä∂ÊÄÅ
        app.state.tradingview_scheduler_service = tradingview_scheduler_service
        
        # ÂàùÂßãÂåñÁΩëÊ†º‰∫§ÊòìË∞ÉÂ∫¶Âô®Êâ©Â±ï
        try:
            from app.services.core.grid_scheduler_extension import get_grid_scheduler_extension
            
            grid_extension = await get_grid_scheduler_extension()
            app.state.grid_scheduler_extension = grid_extension
            
            logger.info("‚úÖ ÁΩëÊ†º‰∫§ÊòìË∞ÉÂ∫¶Âô®Êâ©Â±ïÂàùÂßãÂåñÊàêÂäü")
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è ÁΩëÊ†º‰∫§ÊòìË∞ÉÂ∫¶Âô®Êâ©Â±ïÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            app.state.grid_scheduler_extension = None
        
        # Ê∑ªÂä†KronosÊåÅ‰ªìÂàÜÊûêÂÆöÊó∂‰ªªÂä° - Â∏ÅÂÆâ‰∫§ÊòìÊâÄË∑≥Ëøá
        if settings.kronos_config.get('enable_kronos_prediction', False):
            # Ê£ÄÊü•‰∫§ÊòìÊâÄÁ±ªÂûãÔºåÂ∏ÅÂÆâË∑≥ËøáÊåÅ‰ªìÂàÜÊûê
            if settings.exchange_provider.lower() == 'binance':
                logger.info("üì¥ Â∏ÅÂÆâ‰∫§ÊòìÊâÄË∑≥ËøáKronosÊåÅ‰ªìÂàÜÊûêÂäüËÉΩ")
                app.state.startup_position_analysis = {
                    "status": "skipped", 
                    "message": "Â∏ÅÂÆâ‰∫§ÊòìÊâÄÊöÇ‰∏çÊîØÊåÅÊåÅ‰ªìÂàÜÊûê",
                    "exchange_provider": "binance"
                }
                app.state.kronos_position_service = None
            else:
                from app.services.analysis.kronos_position_analysis_service import get_kronos_position_service
                
                # ‰ΩøÁî®ÂÖ®Â±ÄÂçï‰æãÂÆû‰æãÔºåÁ°Æ‰øùÁä∂ÊÄÅ‰∏ÄËá¥
                kronos_position_service = await get_kronos_position_service()
                
                # ÂêØÂä®Êó∂Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°KronosÊåÅ‰ªìÂàÜÊûê
                try:
                    logger.info("ü§ñ ÂêØÂä®Êó∂Á´ãÂç≥ÊâßË°åKronosÊåÅ‰ªìÂàÜÊûê...")
                    startup_position_result = await kronos_position_service.run_startup_analysis()
                    app.state.startup_position_analysis = startup_position_result
                    
                    if startup_position_result.get("status") == "success":
                        positions_count = startup_position_result.get("positions_analyzed", 0)
                        logger.info(f"‚úÖ ÂêØÂä®KronosÊåÅ‰ªìÂàÜÊûêÂÆåÊàê: ÂàÜÊûê‰∫Ü {positions_count} ‰∏™ÊåÅ‰ªì")
                    elif startup_position_result.get("status") == "no_positions":
                        logger.info("üìä ÂΩìÂâçÊó†ÊåÅ‰ªìÔºåË∑≥ËøáKronosÊåÅ‰ªìÂàÜÊûê")
                    else:
                        logger.warning(f"‚ö†Ô∏è ÂêØÂä®KronosÊåÅ‰ªìÂàÜÊûêÂºÇÂ∏∏: {startup_position_result.get('reason', 'Êú™Áü•')}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è ÂêØÂä®KronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•: {e}")
                    app.state.startup_position_analysis = {"status": "error", "error": str(e)}
                
                # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®Áõ∏ÂêåÁöÑÂÆöÊó∂‰ªªÂä°ÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
                existing_job = scheduler.get_job('kronos_position_analysis')
                if existing_job:
                    logger.warning("‚ö†Ô∏è KronosÊåÅ‰ªìÂàÜÊûê‰ªªÂä°Â∑≤Â≠òÂú®ÔºåË∑≥ËøáÈáçÂ§çÊ∑ªÂä†")
                else:
                    # ÊØè60ÂàÜÈíüÊâßË°å‰∏ÄÊ¨°KronosÊåÅ‰ªìÂàÜÊûêÂíåÊé®ÈÄÅ
                    scheduler.add_job(
                        kronos_position_service.run_scheduled_analysis,
                        'interval',
                        minutes=60,
                        id='kronos_position_analysis',
                        name='KronosÊåÅ‰ªìÂàÜÊûêÂíåÈ£éÈô©ËØÑ‰º∞',
                        max_instances=1  # Á°Æ‰øùÂêåÊó∂Âè™Êúâ‰∏Ä‰∏™ÂÆû‰æãËøêË°å
                    )
                    logger.info("‚úÖ KronosÊåÅ‰ªìÂàÜÊûêÂÆöÊó∂‰ªªÂä°Â∑≤ÂêØÂä® (ÊØè60ÂàÜÈíü)")
                
                # Â∞ÜÊúçÂä°Â≠òÂÇ®Âà∞Â∫îÁî®Áä∂ÊÄÅ
                app.state.kronos_position_service = kronos_position_service
        
        # üöÄ ÂêØÂä®Êó∂Êåâ‰ºòÂÖàÁ∫ßÈ°∫Â∫èÊâßË°åÂàÜÊûê‰ªªÂä° - Ê†∏ÂøÉÂ∏ÅÁßçÊìç‰ΩúÂª∫ËÆÆ‰ºòÂÖà
        logger.info("üöÄ ÂºÄÂßãÊåâ‰ºòÂÖàÁ∫ßÈ°∫Â∫èÊâßË°åÂêØÂä®ÂàÜÊûê‰ªªÂä°...")
        
        # Á¨¨‰∏Ä‰ºòÂÖàÁ∫ßÔºöÊ†∏ÂøÉÂ∏ÅÁßçÊìç‰ΩúÂª∫ËÆÆÊé®ÈÄÅ (ÊúÄÈáçË¶Å)
        logger.info("üìä Á¨¨‰∏Ä‰ºòÂÖàÁ∫ßÔºöÊâßË°åÊ†∏ÂøÉÂ∏ÅÁßçÊìç‰ΩúÂª∫ËÆÆÊé®ÈÄÅ...")
        core_symbols_result = await perform_startup_core_symbols_push()
        setattr(app.state, 'startup_core_symbols_push_results', core_symbols_result)
        
        if core_symbols_result["status"] == "success":
            logger.info("‚úÖ Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂÆåÊàêÔºåÁªßÁª≠ÊâßË°åÂÖ∂‰ªñ‰ªªÂä°")
        else:
            logger.warning(f"‚ö†Ô∏è Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂ§±Ë¥•: {core_symbols_result.get('error', 'Êú™Áü•ÈîôËØØ')}")
        
        # Á¨¨‰∫å‰ºòÂÖàÁ∫ßÔºöÂπ∂ÂèëÊâßË°åÂÖ∂‰ªñÂàÜÊûê‰ªªÂä°
        logger.info("üîÑ Á¨¨‰∫å‰ºòÂÖàÁ∫ßÔºöÂπ∂ÂèëÊâßË°åÂÖ∂‰ªñÂàÜÊûê‰ªªÂä°...")
        startup_tasks = []
        
        # 1. ÂÖºÂÆπÊÄß‰∫§ÊòìÂàÜÊûê‰ªªÂä°
        startup_tasks.append(("trading_analysis", perform_startup_trading_analysis()))
        
        # 2. Ë¥üË¥πÁéáÂàÜÊûê‰ªªÂä° (Áé∞Âú®Âú®Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ‰πãÂêé)
        startup_tasks.append(("funding_analysis", perform_startup_funding_analysis()))
        
        # 3. Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÂàÜÊûê‰ªªÂä°
        startup_tasks.append(("market_anomaly_analysis", perform_startup_market_anomaly_analysis()))
        
        # 4. ÁΩëÊ†º‰∫§ÊòìÊú∫‰ºöÊé®Ëçê‰ªªÂä°
        startup_tasks.append(("grid_trading_analysis", perform_startup_grid_trading_analysis()))
        

        
        # Âπ∂ÂèëÊâßË°åÊâÄÊúâÂêØÂä®‰ªªÂä°
        task_names = [name for name, _ in startup_tasks]
        task_coroutines = [task for _, task in startup_tasks]
        
        logger.info(f"üìä ÂáÜÂ§áÂπ∂ÂèëÊâßË°å {len(task_coroutines)} ‰∏™ÂêØÂä®‰ªªÂä°: {task_names}")
        
        # ‰ΩøÁî® asyncio.gather Âπ∂ÂèëÊâßË°åÔºåÂÖÅËÆ∏ÈÉ®ÂàÜÂ§±Ë¥•
        startup_results = await asyncio.gather(*task_coroutines, return_exceptions=True)
        
        # Â§ÑÁêÜÂπ∂ÂèëÊâßË°åÁªìÊûú (‰∏çÂåÖÊã¨Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÔºåÂ∑≤ÂçïÁã¨ÊâßË°å)
        successful_tasks = 1 if core_symbols_result["status"] == "success" else 0  # Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÁªìÊûú
        failed_tasks = 0 if core_symbols_result["status"] == "success" else 1
        
        for i, (task_name, result) in enumerate(zip(task_names, startup_results)):
            if isinstance(result, Exception):
                logger.warning(f"‚ö†Ô∏è ÂêØÂä®‰ªªÂä° {task_name} Â§±Ë¥•: {result}")
                setattr(app.state, f"startup_{task_name}_results", {"status": "error", "error": str(result)})
                failed_tasks += 1
            else:
                logger.info(f"‚úÖ ÂêØÂä®‰ªªÂä° {task_name} ÂÆåÊàê")
                setattr(app.state, f"startup_{task_name}_results", result)
                successful_tasks += 1
        
        # ËÆ∞ÂΩïÊâßË°åÊÄªÁªì (ÂåÖÊã¨Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ)
        total_tasks = len(task_coroutines) + 1  # +1 for core_symbols_push
        logger.info(f"üéØ ÂêØÂä®‰ªªÂä°ÊâßË°åÂÆåÊàê: {successful_tasks}/{total_tasks} ÊàêÂäü, {failed_tasks} Â§±Ë¥•")
        logger.info(f"üìä Ê†∏ÂøÉÂ∏ÅÁßçÊìç‰ΩúÂª∫ËÆÆÂ∑≤‰ºòÂÖàÊâßË°åÔºåË¥üË¥πÁéáÊú∫‰ºöÂàÜÊûêÈöèÂêéÊâßË°å")
        
        # ËÆæÁΩÆÈªòËÆ§Áä∂ÊÄÅ (ÂÖºÂÆπÊÄß)
        if not hasattr(app.state, 'startup_news_analysis_results'):
            app.state.startup_news_analysis_results = {"status": "disabled"}
        if not hasattr(app.state, 'startup_kronos_market_scan_results'):
            app.state.startup_kronos_market_scan_results = {"status": "disabled"}
        
        logger.info("üìä ÂêØÂä®ÊëòË¶ÅÈÄöÁü•Â∑≤Á¶ÅÁî® - Á≥ªÁªüÁä∂ÊÄÅ‰ø°ÊÅØ‰∏çÊé®ÈÄÅ")
        
        # ÂàùÂßãÂåñKronosÈ¢ÑÊµãÊúçÂä°ÔºàÂèØÈÄâÔºâ
        if settings.kronos_config.get('enable_kronos_prediction', False):
            try:
                from app.services.ml.kronos_prediction_service import get_kronos_service
                kronos_service = await get_kronos_service()
                logger.info("‚úÖ KronosÈ¢ÑÊµãÊúçÂä°ÂàùÂßãÂåñÊàêÂäü")
                app.state.kronos_service = kronos_service
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è KronosÈ¢ÑÊµãÊúçÂä°ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
                logger.info("üí° KronosÊúçÂä°Â∞ÜÂú®È¶ñÊ¨°Ë∞ÉÁî®Êó∂Â∞ùËØïÈáçÊñ∞ÂàùÂßãÂåñ")
                app.state.kronos_service = None
        
        # ÂàùÂßãÂåñMLÂ¢ûÂº∫ÊúçÂä°ÔºàÂèØÈÄâÔºâ
        if settings.ml_config.get('enable_ml_prediction', False):
            ml_service = MLEnhancedService()
            try:
                await ml_service.initialize_models(settings.monitored_symbols)
                logger.info("‚úÖ MLÂ¢ûÂº∫ÊúçÂä°ÂàùÂßãÂåñÊàêÂäü")
                app.state.ml_service = ml_service
                
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è MLÂ¢ûÂº∫ÊúçÂä°ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
                app.state.ml_service = None
        
        # ÂêØÂä®ÈÖçÁΩÆÁõëÊéßÊúçÂä°
        try:
            from app.services.exchanges.config_monitor import start_config_monitoring
            config_monitor_result = await start_config_monitoring()
            
            if config_monitor_result['status'] == 'success':
                logger.info("‚úÖ ÈÖçÁΩÆÁõëÊéßÊúçÂä°ÂêØÂä®ÊàêÂäü")
            else:
                logger.warning(f"‚ö†Ô∏è ÈÖçÁΩÆÁõëÊéßÊúçÂä°ÂêØÂä®Â§±Ë¥•: {config_monitor_result.get('error')}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è ÈÖçÁΩÆÁõëÊéßÊúçÂä°ÂêØÂä®ÂºÇÂ∏∏: {e}")
        
        # Â∞ÜÊúçÂä°ÂÆû‰æãÂ≠òÂÇ®Âà∞Â∫îÁî®Áä∂ÊÄÅ
        app.state.scheduler = scheduler
        
        # ÂêØÂä®ÈÄÇÈÖçÂô®ÁõëÊéßÊúçÂä°
        try:
            logger.info("üîç ÂêØÂä®ÈÄÇÈÖçÂô®ÁõëÊéßÊúçÂä°...")
            from app.services.monitoring.adapter_monitoring_service import start_adapter_monitoring
            await start_adapter_monitoring()
            logger.info("‚úÖ ÈÄÇÈÖçÂô®ÁõëÊéßÊúçÂä°ÂêØÂä®ÊàêÂäü")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è ÈÄÇÈÖçÂô®ÁõëÊéßÊúçÂä°ÂêØÂä®Â§±Ë¥•: {e}")
        
        logger.info("üéâ Application startup completed!")
        
        yield
        
        # Â∫îÁî®ÂÖ≥Èó≠Êó∂ÁöÑÊ∏ÖÁêÜÂ∑•‰Ωú
        logger.info("üõë Shutting down application...")
        
        # 0. ÂÅúÊ≠¢ÈÄÇÈÖçÂô®ÁõëÊéßÊúçÂä°
        try:
            logger.info("üîç ÂÅúÊ≠¢ÈÄÇÈÖçÂô®ÁõëÊéßÊúçÂä°...")
            from app.services.monitoring.adapter_monitoring_service import stop_adapter_monitoring
            await stop_adapter_monitoring()
            logger.info("‚úÖ ÈÄÇÈÖçÂô®ÁõëÊéßÊúçÂä°Â∑≤ÂÅúÊ≠¢")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è ÂÅúÊ≠¢ÈÄÇÈÖçÂô®ÁõëÊéßÊúçÂä°Â§±Ë¥•: {e}")
        
        # 1. ÂÅúÊ≠¢Ë∞ÉÂ∫¶Âô®
        try:
            if hasattr(app.state, 'scheduler') and app.state.scheduler:
                await app.state.scheduler.stop()
                logger.info("‚úÖ General scheduler stopped")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error stopping general scheduler: {e}")
        
        # 1.1 ÂÅúÊ≠¢Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅË∞ÉÂ∫¶Âô®
        try:
            # Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ‰ªªÂä°Â∑≤Êï¥ÂêàÂà∞Áªü‰∏ÄË∞ÉÂ∫¶Âô®‰∏≠ÔºåÊó†ÈúÄÂçïÁã¨ÂÅúÊ≠¢
            pass
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error stopping core scheduler: {e}")
        
        # 2. Ê∏ÖÁêÜÊ†∏ÂøÉHTTPÂÆ¢Êà∑Á´Ø
        try:
            from app.utils.http_manager import cleanup_http_resources
            await cleanup_http_resources()
            logger.info("‚úÖ Core HTTP client cleaned up")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error cleaning up core HTTP client: {e}")
        
        # 3. ÂÅúÊ≠¢ÈÖçÁΩÆÁõëÊéßÊúçÂä°
        try:
            from app.services.exchanges.config_monitor import stop_config_monitoring
            config_stop_result = await stop_config_monitoring()
            if config_stop_result['status'] == 'success':
                logger.info("‚úÖ ÈÖçÁΩÆÁõëÊéßÊúçÂä°ÂÅúÊ≠¢ÂÆåÊàê")
            else:
                logger.warning(f"‚ö†Ô∏è ÈÖçÁΩÆÁõëÊéßÊúçÂä°ÂÅúÊ≠¢Â§±Ë¥•: {config_stop_result.get('error')}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error stopping config monitoring: {e}")
        
        # 4. Ê∏ÖÁêÜ‰∫§ÊòìÊâÄÊúçÂä°
        try:
            from app.services.exchanges.service_manager import stop_exchange_services
            stop_result = await stop_exchange_services()
            if stop_result['status'] == 'success':
                logger.info("‚úÖ ‰∫§ÊòìÊâÄÊúçÂä°Ê∏ÖÁêÜÂÆåÊàê")
            else:
                logger.warning(f"‚ö†Ô∏è ‰∫§ÊòìÊâÄÊúçÂä°Ê∏ÖÁêÜÂ§±Ë¥•: {stop_result.get('error')}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error cleaning up exchange services: {e}")
        
        # 5. Ê∏ÖÁêÜ‰∫§ÊòìÊâÄÊúçÂä°ËøûÊé•
        try:
            from app.services.exchanges.factory import cleanup_all_exchanges
            await cleanup_all_exchanges()
            logger.info("‚úÖ ‰∫§ÊòìÊâÄËøûÊé•Ê∏ÖÁêÜÂÆåÊàê")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error cleaning up exchange connections: {e}")
        
        # 6. ÈÄöÁî® HTTP ËøûÊé•Ê∏ÖÁêÜÔºàÂÖºÂÆπÊÄßÔºâ
        try:
            import gc
            import aiohttp
            
            # Êî∂ÈõÜÊâÄÊúâÂâ©‰ΩôÁöÑ aiohttp.ClientSession ÂØπË±°Âπ∂ÂÖ≥Èó≠
            cleaned_count = 0
            for obj in gc.get_objects():
                if isinstance(obj, aiohttp.ClientSession) and not obj.closed:
                    try:
                        await obj.close()
                        cleaned_count += 1
                    except Exception as e:
                        logger.debug(f"‚ö†Ô∏è Error closing remaining session: {e}")
            
            if cleaned_count > 0:
                await asyncio.sleep(0.2)
                logger.info(f"‚úÖ Cleaned up {cleaned_count} remaining HTTP sessions")
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error in general HTTP cleanup: {e}")
        
        # 4. Ê∏ÖÁêÜÊï∞ÊçÆÂ∫ìËøûÊé•
        try:
            if hasattr(app.state, 'database_available') and app.state.database_available and db_manager:
                if hasattr(db_manager, 'close_all_connections'):
                    await db_manager.close_all_connections()
                    logger.info("‚úÖ Database connections closed")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error closing database connections: {e}")
        
        # 5. Ê∏ÖÁêÜÂÖ∂‰ªñÊúçÂä°
        try:
            # Ê∏ÖÁêÜ Kronos ÊúçÂä°
            if hasattr(app.state, 'kronos_service') and app.state.kronos_service:
                # Kronos ÊúçÂä°ÈÄöÂ∏∏‰∏çÈúÄË¶ÅÁâπÊÆäÊ∏ÖÁêÜ
                pass
            
            # Ê∏ÖÁêÜ ML ÊúçÂä°
            if hasattr(app.state, 'ml_service') and app.state.ml_service:
                # ML ÊúçÂä°ÈÄöÂ∏∏‰∏çÈúÄË¶ÅÁâπÊÆäÊ∏ÖÁêÜ
                pass
                
            logger.info("‚úÖ Services cleaned up")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error cleaning up services: {e}")
        
        logger.info("üéØ Application shutdown completed")
        
    except Exception as e:
        logger.error(f"‚ùå Application startup failed: {e}")
        raise
    
    # ÂÖ≥Èó≠Êó∂ÊâßË°å
    logger.info("üõë Shutting down Python Trading Analysis Tool...")
    
    try:
        # ÂÅúÊ≠¢Ë∞ÉÂ∫¶Âô®
        if hasattr(app.state, 'scheduler'):
            await app.state.scheduler.stop()
            logger.info("‚úÖ Scheduler stopped")
        
        # Ê∏ÖÁêÜHTTPËøûÊé•Ê±†
        try:
            from app.utils.http_manager import cleanup_http_resources
            await cleanup_http_resources()
            logger.info("‚úÖ HTTP connection pool cleaned up")
        except Exception as e:
            logger.error(f"‚ö†Ô∏è HTTP cleanup error: {e}")
        
        # Ê∏ÖÁêÜÊï∞ÊçÆÂ∫ìËøûÊé•
        try:
            if db_manager and hasattr(db_manager, 'close_all_connections'):
                db_manager.close_all_connections()
                logger.info("‚úÖ Database connections closed")
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Database cleanup error: {e}")
        
        logger.info("üëã Application shutdown completed!")
        
    except Exception as e:
        logger.error(f"‚ùå Application shutdown error: {e}")

def create_app() -> FastAPI:
    """ÂàõÂª∫FastAPIÂ∫îÁî®"""
    
    app = FastAPI(
        title="Python Trading Analysis Tool",
        description="Python ‰∫§ÊòìÂàÜÊûêÂ∑•ÂÖ∑ - Êèê‰æõË∂ãÂäøÂàÜÊûê„ÄÅË¥πÁéáÁõëÊéß„ÄÅÊåÅ‰ªìÈáèÂèòÂåñÁõëÊéßÁ≠âÂäüËÉΩ",
        version=settings.app_version,
        docs_url="/docs" if settings.debug else None,
        redoc_url="/redoc" if settings.debug else None,
        lifespan=lifespan
    )
    
    # Ê∑ªÂä†CORS‰∏≠Èó¥‰ª∂
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"] if settings.debug else ["http://localhost:3000"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Ê≥®ÂÜåË∑ØÁî± - Ê†∏ÂøÉÊï¥ÂêàAPI‰ºòÂÖà
    app.include_router(core_trading_router, tags=["Ê†∏ÂøÉ‰∫§Êòì"])
    
    # Â¢ûÂº∫‰∫§ÊòìÂàÜÊûêAPI
    app.include_router(enhanced_trading_router, prefix="/api/enhanced", tags=["Â¢ûÂº∫‰∫§ÊòìÂàÜÊûê"])
    
    # ÂéüÊúâË∑ØÁî± - ‰øùÊåÅÂÖºÂÆπÊÄß
    app.include_router(trend_router, prefix="/api/trend", tags=["Ë∂ãÂäøÂàÜÊûê"])
    app.include_router(monitor_router, prefix="/api/monitor", tags=["ÁõëÊéßÊúçÂä°"])
    app.include_router(notification_router, prefix="/api/notification", tags=["ÈÄöÁü•ÊúçÂä°"])
    app.include_router(tradingview_router, prefix="/api/tradingview", tags=["TradingViewÂäüËÉΩ"])
    app.include_router(strategy_router, prefix="/api/strategy", tags=["Á≠ñÁï•ÂàÜÊûê"])
    app.include_router(ml_enhanced_router, prefix="/api/ml", tags=["Êú∫Âô®Â≠¶‰π†Â¢ûÂº∫"])
    app.include_router(backtest_router, prefix="/api", tags=["ÂõûÊµãÂàÜÊûê"])
    app.include_router(funding_monitor_router, prefix="/api/funding", tags=["Ë¥üË¥πÁéáÁõëÊéß"])
    
    # Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßAPI
    from app.api.market_anomaly import router as market_anomaly_router
    app.include_router(market_anomaly_router, prefix="/api/market-anomaly", tags=["Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéß"])
    
    app.include_router(kronos_router, prefix="/api/kronos", tags=["Kronos AIÈ¢ÑÊµã"])
    app.include_router(kronos_integrated_router, prefix="/api/kronos-integrated", tags=["KronosÈõÜÊàêÂÜ≥Á≠ñ"])
    app.include_router(kronos_market_opportunities_router, prefix="/api/kronos-opportunities", tags=["KronosÂ∏ÇÂú∫Êú∫‰ºö"])
    app.include_router(kronos_advanced_opportunities_router, prefix="/api/kronos-advanced", tags=["KronosÈ´òÁ∫ßÊú∫‰ºö"])

    app.include_router(database_router, prefix="/api/database", tags=["Êï∞ÊçÆÂ∫ìÁÆ°ÁêÜ"])
    app.include_router(http_pool_router, prefix="/api/http-pool", tags=["HTTPËøûÊé•Ê±†ÁÆ°ÁêÜ"])
    app.include_router(trading_pairs_router, prefix="/api/trading-pairs", tags=["‰∫§ÊòìÂØπÁÆ°ÁêÜ"])
    app.include_router(unified_data_router, prefix="/api", tags=["Áªü‰∏ÄÊï∞ÊçÆÊúçÂä°"])
    app.include_router(ml_config_router, prefix="/api/ml-config", tags=["MLÈÖçÁΩÆÁÆ°ÁêÜ"])
    app.include_router(news_router, prefix="/api/news", tags=["Êñ∞ÈóªÂàÜÊûê"])
    
    # TradingViewÊâ´ÊèèÂô®API
    app.include_router(tradingview_scanner_router, prefix="/api/tradingview", tags=["TradingViewÊâ´ÊèèÂô®"])
    app.include_router(tradingview_scheduler_router, prefix="/api/tradingview", tags=["TradingViewË∞ÉÂ∫¶Âô®"])
    
    # ‰∫§ÊòìÊâÄÁÆ°ÁêÜAPI
    from app.api.exchange_management import router as exchange_management_router
    app.include_router(exchange_management_router, tags=["‰∫§ÊòìÊâÄÁÆ°ÁêÜ"])
    
    # Á≥ªÁªüËØäÊñ≠API
    from app.api.system_diagnostics import router as system_diagnostics_router
    app.include_router(system_diagnostics_router, tags=["Á≥ªÁªüËØäÊñ≠"])
    
    # ÁΩëÊ†º‰∫§ÊòìAPI
    from app.api.grid_trading import router as grid_trading_router
    app.include_router(grid_trading_router, tags=["ÁΩëÊ†º‰∫§Êòì"])
    

    
    # Ê†πË∑ØÂæÑ
    @app.get("/", summary="Ê†πË∑ØÂæÑ")
    async def root():
        return {
            "message": "Welcome to Python Trading Analysis Tool",
            "version": settings.app_version,
            "status": "running",
            "docs": "/docs" if settings.debug else "disabled"
        }
    
    # ÂÅ•Â∫∑Ê£ÄÊü•
    @app.get("/health", summary="ÂÅ•Â∫∑Ê£ÄÊü•")
    async def health_check():
        try:
            # Ê£ÄÊü•Êï∞ÊçÆÂ∫ìËøûÊé•ÂíåËøûÊé•Ê±†
            db_healthy = False
            pool_stats = {}
            if DATABASE_AVAILABLE and db_manager and get_db_monitor:
                db_healthy = db_manager.health_check()
                db_monitor = get_db_monitor()
                pool_stats = db_monitor.get_pool_stats() if db_healthy else {}
            
            # Ê£ÄÊü•ÈÄÇÈÖçÂô®Áä∂ÊÄÅ
            adapter_status = {"status": "unknown", "details": {}}
            try:
                from app.services.monitoring.adapter_monitoring_service import get_adapter_monitoring_service
                monitoring_service = get_adapter_monitoring_service()
                adapter_overall_status = await monitoring_service.get_overall_status()
                adapter_status = {
                    "status": adapter_overall_status["status"],
                    "total_exchanges": adapter_overall_status.get("total_exchanges", 0),
                    "status_breakdown": adapter_overall_status.get("status_breakdown", {}),
                    "monitoring_active": adapter_overall_status.get("monitoring_active", False)
                }
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Ëé∑ÂèñÈÄÇÈÖçÂô®Áä∂ÊÄÅÂ§±Ë¥•: {e}")
                adapter_status = {"status": "error", "error": str(e)}
            
            api_healthy = True
            
            # Ê£ÄÊü•Ë∞ÉÂ∫¶Âô®Áä∂ÊÄÅ
            scheduler_healthy = hasattr(app.state, 'scheduler') and app.state.scheduler.is_running()
            
            # Ê£ÄÊü•MLÊúçÂä°Áä∂ÊÄÅ
            ml_healthy = True
            if settings.ml_config.get('enable_ml_prediction', False):
                ml_healthy = hasattr(app.state, 'ml_service') and app.state.ml_service is not None
            
            # ÈÄÇÈÖçÂô®ÂÅ•Â∫∑Áä∂ÊÄÅ
            adapter_healthy = adapter_status["status"] in ["healthy", "degraded"]
            
            status = "healthy" if all([db_healthy, api_healthy, scheduler_healthy, ml_healthy, adapter_healthy]) else "unhealthy"
            
            health_checks = {
                "database": "healthy" if db_healthy else "unhealthy",
                "connection_pool": pool_stats,
                "binance_api": "healthy" if api_healthy else "unhealthy", 
                "scheduler": "healthy" if scheduler_healthy else "unhealthy",
                "data_adapters": adapter_status
            }
            
            if settings.ml_config.get('enable_ml_prediction', False):
                health_checks["ml_service"] = "healthy" if ml_healthy else "unhealthy"
            
            return {
                "status": status,
                "timestamp": datetime.now().isoformat(),
                "checks": health_checks
            }
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            raise HTTPException(status_code=500, detail="Health check failed")
    
    # ÈÄÇÈÖçÂô®ÁõëÊéßÁõ∏ÂÖ≥Á´ØÁÇπ
    @app.get("/adapters/status", summary="Ëé∑ÂèñÊâÄÊúâÈÄÇÈÖçÂô®Áä∂ÊÄÅ")
    async def get_adapters_status():
        """Ëé∑ÂèñÊâÄÊúâÊï∞ÊçÆÈÄÇÈÖçÂô®ÁöÑÁä∂ÊÄÅ‰ø°ÊÅØ"""
        try:
            from app.services.monitoring.adapter_monitoring_service import get_adapter_monitoring_service
            monitoring_service = get_adapter_monitoring_service()
            return await monitoring_service.get_all_statuses()
        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÈÄÇÈÖçÂô®Áä∂ÊÄÅÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÈÄÇÈÖçÂô®Áä∂ÊÄÅÂ§±Ë¥•: {str(e)}")
    
    @app.get("/adapters/status/{exchange}", summary="Ëé∑ÂèñÁâπÂÆö‰∫§ÊòìÊâÄÈÄÇÈÖçÂô®Áä∂ÊÄÅ")
    async def get_adapter_status(exchange: str):
        """Ëé∑ÂèñÁâπÂÆö‰∫§ÊòìÊâÄÊï∞ÊçÆÈÄÇÈÖçÂô®ÁöÑÁä∂ÊÄÅ‰ø°ÊÅØ"""
        try:
            from app.services.monitoring.adapter_monitoring_service import get_adapter_monitoring_service
            monitoring_service = get_adapter_monitoring_service()
            return await monitoring_service.get_exchange_status(exchange)
        except Exception as e:
            logger.error(f"‚ùå Ëé∑Âèñ {exchange} ÈÄÇÈÖçÂô®Áä∂ÊÄÅÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÈÄÇÈÖçÂô®Áä∂ÊÄÅÂ§±Ë¥•: {str(e)}")
    
    @app.get("/adapters/performance", summary="Ëé∑ÂèñÈÄÇÈÖçÂô®ÊÄßËÉΩÁªüËÆ°")
    async def get_adapters_performance():
        """Ëé∑ÂèñÊï∞ÊçÆÈÄÇÈÖçÂô®ÁöÑÊÄßËÉΩÁªüËÆ°‰ø°ÊÅØ"""
        try:
            from app.services.monitoring.adapter_monitoring_service import get_adapter_monitoring_service
            monitoring_service = get_adapter_monitoring_service()
            return await monitoring_service.get_performance_summary()
        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÈÄÇÈÖçÂô®ÊÄßËÉΩÁªüËÆ°Â§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÊÄßËÉΩÁªüËÆ°Â§±Ë¥•: {str(e)}")
    
    @app.get("/adapters/errors", summary="Ëé∑ÂèñÈÄÇÈÖçÂô®ÈîôËØØÁªüËÆ°")
    async def get_adapters_errors():
        """Ëé∑ÂèñÊï∞ÊçÆÈÄÇÈÖçÂô®ÁöÑÈîôËØØÁªüËÆ°‰ø°ÊÅØ"""
        try:
            from app.services.monitoring.adapter_monitoring_service import get_adapter_monitoring_service
            monitoring_service = get_adapter_monitoring_service()
            return await monitoring_service.get_error_summary()
        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÈÄÇÈÖçÂô®ÈîôËØØÁªüËÆ°Â§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÈîôËØØÁªüËÆ°Â§±Ë¥•: {str(e)}")
    
    @app.post("/adapters/diagnostics", summary="ËøêË°åÈÄÇÈÖçÂô®ËØäÊñ≠")
    async def run_adapters_diagnostics(exchange: str = None):
        """ËøêË°åÊï∞ÊçÆÈÄÇÈÖçÂô®ÁöÑÁªºÂêàËØäÊñ≠"""
        try:
            from app.services.monitoring.adapter_monitoring_service import get_adapter_monitoring_service
            monitoring_service = get_adapter_monitoring_service()
            return await monitoring_service.run_comprehensive_diagnostics(exchange)
        except Exception as e:
            logger.error(f"‚ùå ËøêË°åÈÄÇÈÖçÂô®ËØäÊñ≠Â§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"ËØäÊñ≠Â§±Ë¥•: {str(e)}")
    
    @app.get("/adapters/monitoring/config", summary="Ëé∑ÂèñÁõëÊéßÈÖçÁΩÆ")
    async def get_monitoring_config():
        """Ëé∑ÂèñÈÄÇÈÖçÂô®ÁõëÊéßÈÖçÁΩÆ"""
        try:
            from app.services.monitoring.adapter_monitoring_service import get_adapter_monitoring_service
            monitoring_service = get_adapter_monitoring_service()
            return monitoring_service.get_monitoring_config()
        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÁõëÊéßÈÖçÁΩÆÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÈÖçÁΩÆÂ§±Ë¥•: {str(e)}")
    
    @app.put("/adapters/monitoring/config", summary="Êõ¥Êñ∞ÁõëÊéßÈÖçÁΩÆ")
    async def update_monitoring_config(config: dict):
        """Êõ¥Êñ∞ÈÄÇÈÖçÂô®ÁõëÊéßÈÖçÁΩÆ"""
        try:
            from app.services.monitoring.adapter_monitoring_service import get_adapter_monitoring_service
            monitoring_service = get_adapter_monitoring_service()
            monitoring_service.update_monitoring_config(config)
            return {"status": "success", "message": "ÁõëÊéßÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞"}
        except Exception as e:
            logger.error(f"‚ùå Êõ¥Êñ∞ÁõëÊéßÈÖçÁΩÆÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Êõ¥Êñ∞ÈÖçÁΩÆÂ§±Ë¥•: {str(e)}")

    # ÂêØÂä®ÂàÜÊûêÁªìÊûú
    @app.get("/startup-analysis", summary="Êü•ÁúãÂêØÂä®ÂàÜÊûêÁªìÊûú")
    async def get_startup_analysis():
        """Ëé∑ÂèñÂ∫îÁî®ÂêØÂä®Êó∂ÁöÑ‰∫§ÊòìÂàÜÊûêÁªìÊûú"""
        try:
            trading_results = None
            funding_results = None
            kronos_results = None
            
            if hasattr(app.state, 'startup_analysis_results'):
                trading_results = app.state.startup_analysis_results
                
            if hasattr(app.state, 'startup_funding_results'):
                funding_results = app.state.startup_funding_results
                
            if hasattr(app.state, 'startup_kronos_results'):
                kronos_results = app.state.startup_kronos_results
            
            return {
                "status": "success",
                "startup_analysis": {
                    "trading_analysis": trading_results,
                    "funding_analysis": funding_results,
                    "kronos_market_scan": kronos_results
                },
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂêØÂä®ÂàÜÊûêÁªìÊûúÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñÂêØÂä®ÂàÜÊûêÁªìÊûúÂ§±Ë¥•")
    
    # KronosÂ∏ÇÂú∫Êú∫‰ºöÂø´ÈÄüÊµãËØï
    @app.get("/kronos-opportunities-test", summary="KronosÂ∏ÇÂú∫Êú∫‰ºöÂø´ÈÄüÊµãËØï")
    async def test_kronos_opportunities():
        """Âø´ÈÄüÊµãËØïKronosÂ∏ÇÂú∫Êú∫‰ºöÊâ´ÊèèÂäüËÉΩ"""
        try:
            from app.services.ml.kronos_market_opportunity_service import get_kronos_market_opportunity_service
            
            market_service = await get_kronos_market_opportunity_service()
            
            # Ëé∑ÂèñÊâ´ÊèèÁä∂ÊÄÅ
            status = await market_service.get_scan_status()
            
            # ÊâßË°åÂø´ÈÄüÂº∫‰ø°Âè∑Êâ´ÊèèÔºàÂº∫Âà∂Ê®°ÂºèÔºâ
            strong_result = await market_service.scan_strong_trading_opportunities(force_scan=True)
            
            return {
                "status": "success",
                "scan_status": status,
                "test_scan_result": strong_result,
                "message": "KronosÂ∏ÇÂú∫Êú∫‰ºöÊâ´ÊèèÊµãËØïÂÆåÊàê",
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"KronosÊú∫‰ºöÊµãËØïÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"ÊµãËØïÂ§±Ë¥•: {str(e)}")
    
    # Ë¥üË¥πÁéáÊú∫‰ºöÂø´ÈÄüÊü•Áúã
    @app.get("/funding-opportunities", summary="Âø´ÈÄüÊü•ÁúãË¥üË¥πÁéáÊú∫‰ºö")
    async def get_funding_opportunities():
        """Âø´ÈÄüÊü•ÁúãÂΩìÂâçË¥üË¥πÁéáÂêÉÂà©ÊÅØÊú∫‰ºö"""
        try:
            if hasattr(app.state, 'funding_monitor'):
                # ‰ΩøÁî®ÁºìÂ≠òÁöÑÁõëÊéßÊúçÂä°ËøõË°åÂø´ÈÄüÊ£ÄÊü•
                funding_monitor = app.state.funding_monitor
                
                # Âø´ÈÄüÊ£ÄÊü•Ââç20‰∏™ÁÉ≠Èó®Â∏ÅÁßç
                hot_symbols = await funding_monitor.get_top_volume_symbols(limit=20)
                
                # ‰ΩøÁî®ÈÖçÁΩÆÁöÑ‰∫§ÊòìÊâÄÊúçÂä°Ëé∑ÂèñË¥πÁéáÊï∞ÊçÆ
                from app.services.exchanges.factory import get_default_exchange
                exchange_service = await get_default_exchange()
                funding_rates = await exchange_service.get_batch_funding_rates(hot_symbols[:15])
                
                # Âè™ÂàÜÊûêË¥üË¥πÁéáÂ∏ÅÁßç
                negative_rates = [r for r in funding_rates if r['funding_rate'] < 0]
                
                if negative_rates:
                    opportunities = []
                    for rate_data in negative_rates:
                        daily_rate = rate_data['funding_rate'] * 3
                        opportunities.append({
                            'symbol': rate_data['symbol'].replace('-USDT-SWAP', ''),
                            'funding_rate_percent': rate_data['funding_rate'] * 100,
                            'daily_rate_percent': abs(daily_rate * 100),
                            'daily_income_10k': abs(daily_rate * 10000),
                            'annual_rate_percent': abs(daily_rate * 365 * 100)
                        })
                    
                    opportunities.sort(key=lambda x: x['funding_rate_percent'])
                    
                    return {
                        "status": "success",
                        "message": f"ÂèëÁé∞ {len(opportunities)} ‰∏™Ë¥üË¥πÁéáÊú∫‰ºö",
                        "opportunities": opportunities[:8],
                        "timestamp": datetime.now().isoformat()
                    }
                else:
                    return {
                        "status": "success",
                        "message": "ÂΩìÂâçÊó†Ë¥üË¥πÁéáÊú∫‰ºö",
                        "opportunities": [],
                        "timestamp": datetime.now().isoformat()
                    }
            else:
                return {
                    "status": "error",
                    "message": "Ë¥üË¥πÁéáÁõëÊéßÊúçÂä°Êú™ÂêØÂä®",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñË¥üË¥πÁéáÊú∫‰ºöÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñË¥üË¥πÁéáÊú∫‰ºöÂ§±Ë¥•")
    
    # ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéß
    @app.post("/test-funding-monitor", summary="ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéß")
    async def test_funding_monitor():
        """ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéßÔºåÁî®‰∫éÊµãËØïÊé®ÈÄÅÂäüËÉΩ"""
        try:
            if hasattr(app.state, 'funding_monitor'):
                funding_monitor = app.state.funding_monitor
                logger.info("üß™ ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéßÊµãËØï...")
                
                # ËøêË°åÂÆåÊï¥ÁöÑÁõëÊéßÂë®Êúü
                result = await funding_monitor.run_monitoring_cycle(enable_enhanced_analysis=True)
                
                if result['success']:
                    return {
                        "status": "success",
                        "message": f"ÁõëÊéßÂÆåÊàêÔºåÂèëÁé∞ {result.get('negative_funding_count', 0)} ‰∏™Ë¥üË¥πÁéáÊú∫‰ºö",
                        "data": {
                            "total_symbols_checked": result.get('total_symbols_checked', 0),
                            "opportunities_count": result.get('negative_funding_count', 0),
                            "duration_seconds": result.get('duration_seconds', 0),
                            "analysis_time": result.get('analysis_time')
                        },
                        "timestamp": datetime.now().isoformat()
                    }
                else:
                    return {
                        "status": "error",
                        "message": f"ÁõëÊéßÂ§±Ë¥•: {result.get('error', 'Êú™Áü•ÈîôËØØ')}",
                        "timestamp": datetime.now().isoformat()
                    }
            else:
                return {
                    "status": "error",
                    "message": "Ë¥üË¥πÁéáÁõëÊéßÊúçÂä°Êú™ÂêØÂä®",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"ÊâãÂä®Ëß¶ÂèëË¥üË¥πÁéáÁõëÊéßÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"ÁõëÊéßÂ§±Ë¥•: {str(e)}")
    
    # Â∏ÇÂú∫ÂºÇÂ∏∏Âø´ÈÄüÊü•Áúã
    @app.get("/market-anomalies", summary="Âø´ÈÄüÊü•ÁúãÂ∏ÇÂú∫ÂºÇÂ∏∏")
    async def get_market_anomalies():
        """Âø´ÈÄüÊü•ÁúãÂΩìÂâçÂ∏ÇÂú∫ÂºÇÂ∏∏ÊÉÖÂÜµ"""
        try:
            if hasattr(app.state, 'market_anomaly_service'):
                service = app.state.market_anomaly_service
                logger.info("üîç Âø´ÈÄüÊü•ÁúãÂ∏ÇÂú∫ÂºÇÂ∏∏...")
                
                # Êâ´ÊèèÂºÇÂ∏∏ÔºàÂè™ËøîÂõûÊé®ËçêÁöÑÔºâ
                anomalies, total_checked = await service.scan_market_anomalies(
                    min_anomaly_level=AnomalyLevel.MEDIUM,
                    only_recommended=True
                )
                
                if anomalies:
                    # ÊûÑÂª∫ÁÆÄÂåñÁöÑÂìçÂ∫î
                    top_anomalies = anomalies[:8]  # Âè™ËøîÂõûÂâç8‰∏™
                    anomaly_list = []
                    
                    for anomaly in top_anomalies:
                        anomaly_list.append({
                            'symbol': anomaly.symbol_name,
                            'score': anomaly.anomaly_score,
                            'trend': anomaly.trend_direction.value,
                            'price_change_24h': f"{anomaly.price_change_24h * 100:+.1f}%",
                            'volume_ratio': f"{anomaly.volume_ratio:.1f}x",
                            'anomaly_level': anomaly.overall_anomaly_level.value,
                            'main_reason': anomaly.recommendation_reason[0] if anomaly.recommendation_reason else "",
                            'current_price': anomaly.current_price
                        })
                    
                    return {
                        "status": "success",
                        "message": f"ÂèëÁé∞ {len(anomalies)} ‰∏™Â∏ÇÂú∫ÂºÇÂ∏∏",
                        "anomalies": anomaly_list,
                        "summary": {
                            "total_anomalies": len(anomalies),
                            "strong_uptrend": sum(1 for a in anomalies if a.trend_direction.value in ['strong_up', 'up']),
                            "high_volume": sum(1 for a in anomalies if a.volume_ratio > 2.0)
                        },
                        "timestamp": datetime.now().isoformat()
                    }
                else:
                    return {
                        "status": "success",
                        "message": "ÂΩìÂâçÊó†ÊòæËëóÂ∏ÇÂú∫ÂºÇÂ∏∏",
                        "anomalies": [],
                        "summary": {
                            "total_anomalies": 0,
                            "strong_uptrend": 0,
                            "high_volume": 0
                        },
                        "timestamp": datetime.now().isoformat()
                    }
            else:
                return {
                    "status": "error",
                    "message": "Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÊúçÂä°Êú™ÂêØÂä®",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂ∏ÇÂú∫ÂºÇÂ∏∏Â§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñÂ∏ÇÂú∫ÂºÇÂ∏∏Â§±Ë¥•")
    
    # ÊâãÂä®Ëß¶ÂèëÂ∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéß
    @app.post("/test-market-anomaly-monitor", summary="ÊâãÂä®Ëß¶ÂèëÂ∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéß")
    async def test_market_anomaly_monitor():
        """ÊâãÂä®Ëß¶ÂèëÂ∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÔºåÁî®‰∫éÊµãËØïÊé®ÈÄÅÂäüËÉΩ"""
        try:
            if hasattr(app.state, 'market_anomaly_service'):
                service = app.state.market_anomaly_service
                logger.info("üß™ ÊâãÂä®Ëß¶ÂèëÂ∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÊµãËØï...")
                
                # ËøêË°åÂÆåÊï¥ÁöÑÁõëÊéßÂë®Êúü
                result = await service.run_monitoring_cycle()
                
                if result['success']:
                    return {
                        "status": "success",
                        "message": f"ÁõëÊéßÂÆåÊàêÔºåÂèëÁé∞ {result.get('anomalies_found', 0)} ‰∏™ÂºÇÂ∏∏ÔºåÊé®Ëçê {result.get('recommended_count', 0)} ‰∏™",
                        "data": {
                            "anomalies_found": result.get('anomalies_found', 0),
                            "recommended_count": result.get('recommended_count', 0),
                            "notification_sent": result.get('anomalies_found', 0) > 0
                        },
                        "timestamp": result.get('timestamp')
                    }
                else:
                    return {
                        "status": "error",
                        "message": f"ÁõëÊéßÂ§±Ë¥•: {result.get('error', 'Êú™Áü•ÈîôËØØ')}",
                        "timestamp": result.get('timestamp')
                    }
            else:
                return {
                    "status": "error",
                    "message": "Â∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÊúçÂä°Êú™ÂêØÂä®",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"ÊâãÂä®Ëß¶ÂèëÂ∏ÇÂú∫ÂºÇÂ∏∏ÁõëÊéßÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"ÁõëÊéßÂ§±Ë¥•: {str(e)}")
    
    # Âø´ÈÄüÂ∏ÇÂú∫Ê¶ÇËßà
    @app.get("/market-overview", summary="Âø´ÈÄüÂ∏ÇÂú∫Ê¶ÇËßà")
    async def get_market_overview():
        """Ëé∑ÂèñÂΩìÂâçÂ∏ÇÂú∫Âø´ÈÄüÊ¶ÇËßà"""
        try:
            from app.services.startup_trading_service import StartupTradingService
            startup_service = StartupTradingService()
            
            overview = await startup_service.get_quick_market_overview()
            
            return {
                "status": "success",
                "market_overview": overview,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂ∏ÇÂú∫Ê¶ÇËßàÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñÂ∏ÇÂú∫Ê¶ÇËßàÂ§±Ë¥•")
    
    # KronosÊåÅ‰ªìÂàÜÊûêÊä•Âëä
    @app.get("/kronos-position-analysis", summary="KronosÊåÅ‰ªìÂàÜÊûêÊä•Âëä")
    async def get_kronos_position_analysis():
        """Ëé∑ÂèñÂü∫‰∫éKronosÈ¢ÑÊµãÁöÑÊåÅ‰ªìÂàÜÊûêÊä•Âëä"""
        try:
            # Ê£ÄÊü•‰∫§ÊòìÊâÄÁ±ªÂûãÔºåÂ∏ÅÂÆâË∑≥ËøáÊåÅ‰ªìÂàÜÊûê
            if settings.exchange_provider.lower() == 'binance':
                return {
                    "status": "skipped",
                    "message": "Â∏ÅÂÆâ‰∫§ÊòìÊâÄÊöÇ‰∏çÊîØÊåÅÊåÅ‰ªìÂàÜÊûêÂäüËÉΩ",
                    "exchange_provider": "binance",
                    "timestamp": datetime.now().isoformat()
                }
            
            from app.services.ml.kronos_integrated_decision_service import get_kronos_integrated_service
            
            kronos_service = await get_kronos_integrated_service()
            
            # ÂàÜÊûê‰∏ªË¶ÅÊåÅ‰ªìÂ∏ÅÁßç
            symbols = ["ETH-USDT-SWAP", "SOL-USDT-SWAP"]
            analysis_results = {}
            
            for symbol in symbols:
                decision = await kronos_service.get_kronos_enhanced_decision(symbol, force_update=True)
                if decision:
                    analysis_results[symbol] = {
                        "symbol": symbol.replace("-USDT-SWAP", ""),
                        "kronos_confidence": decision.kronos_confidence,
                        "signal_strength": decision.kronos_signal_strength.value,
                        "final_action": decision.final_action,
                        "final_confidence": decision.final_confidence,
                        "reasoning": decision.reasoning,
                        "kronos_analysis": getattr(decision, 'kronos_analysis', {}),
                        "position_recommendation": decision.position_recommendation.value if decision.position_recommendation else "Êó†Âª∫ËÆÆ",
                        "risk_level": decision.position_risk.value if decision.position_risk else "Êú™Áü•"
                    }
            
            return {
                "status": "success",
                "message": f"KronosÊåÅ‰ªìÂàÜÊûêÂÆåÊàêÔºåÂàÜÊûê‰∫Ü {len(analysis_results)} ‰∏™Â∏ÅÁßç",
                "analysis_results": analysis_results,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñKronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñKronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•")
    
    # ÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûê (Âü∫‰∫éÂÆûÈôÖÊåÅ‰ªì)
    @app.get("/kronos-live-position-analysis", summary="ÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûê")
    async def get_kronos_live_position_analysis():
        """Ëé∑ÂèñÂü∫‰∫éÂÆûÈôÖÊåÅ‰ªìÁöÑKronosÂàÜÊûêÊä•Âëä"""
        try:
            # Ê£ÄÊü•‰∫§ÊòìÊâÄÁ±ªÂûãÔºåÂ∏ÅÂÆâË∑≥ËøáÊåÅ‰ªìÂàÜÊûê
            if settings.exchange_provider.lower() == 'binance':
                return {
                    "status": "skipped",
                    "message": "Â∏ÅÂÆâ‰∫§ÊòìÊâÄÊöÇ‰∏çÊîØÊåÅÂÆûÊó∂ÊåÅ‰ªìÂàÜÊûêÂäüËÉΩ",
                    "exchange_provider": "binance",
                    "timestamp": datetime.now().isoformat()
                }
            
            from app.services.analysis.kronos_position_analysis_service import get_kronos_position_service
            
            kronos_position_service = await get_kronos_position_service()
            
            # ÊâßË°åÂÆûÊó∂ÂàÜÊûê
            analysis_result = await kronos_position_service.get_manual_analysis()
            
            return {
                "status": "success",
                "message": "ÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûêÂÆåÊàê",
                "analysis_result": analysis_result,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail="Ëé∑ÂèñÂÆûÊó∂KronosÊåÅ‰ªìÂàÜÊûêÂ§±Ë¥•")
    
    @app.get("/test-technical-config", summary="ÊµãËØïÊäÄÊúØÂàÜÊûêÈÖçÁΩÆ")
    async def test_technical_config():
        """ÊµãËØïÊäÄÊúØÂàÜÊûêÈÖçÁΩÆÊòØÂê¶Ê≠£Á°Æ"""
        try:
            from app.core.technical_analysis_config import get_technical_config
            
            config_manager = get_technical_config()
            config = config_manager.get_config()
            
            # È™åËØÅÊùÉÈáç
            total_weight = sum(config.indicator_weights.values())
            
            return {
                "status": "success",
                "weights": config.indicator_weights,
                "total_weight": total_weight,
                "is_valid": total_weight == 100,
                "rsi_params": {
                    "period": config.rsi_period,
                    "overbought": config.rsi_overbought,
                    "oversold": config.rsi_oversold
                },
                "macd_params": {
                    "fast": config.macd_fast,
                    "slow": config.macd_slow,
                    "signal": config.macd_signal
                }
            }
            
        except Exception as e:
            logger.error(f"ÊµãËØïÊäÄÊúØÂàÜÊûêÈÖçÁΩÆÂ§±Ë¥•: {e}")
            return {"status": "error", "message": str(e)}
    
    @app.post("/test-enhanced-analysis", summary="ÊµãËØïÂ¢ûÂº∫ÁöÑÁªºÂêàÂàÜÊûê")
    async def test_enhanced_analysis(symbol: str = "BTC-USDT-SWAP"):
        """ÊµãËØïKronos+ÊäÄÊúØÂàÜÊûê+MLÁöÑÁªºÂêàÂàÜÊûê"""
        try:
            from app.services.trading.core_trading_service import get_core_trading_service, AnalysisType
            
            core_trading_service = await get_core_trading_service()
            
            # ÊâßË°åÁªºÂêàÂàÜÊûê
            trading_signal = await core_trading_service.analyze_symbol(
                symbol=symbol,
                analysis_type=AnalysisType.INTEGRATED,
                force_update=True
            )
            
            if not trading_signal:
                return {"status": "error", "message": f"ÂàÜÊûê {symbol} Â§±Ë¥•"}
            
            # ÊûÑÂª∫ËØ¶ÁªÜÁöÑÂàÜÊûêÁªìÊûú
            result = {
                "status": "success",
                "symbol": symbol,
                "analysis_time": trading_signal.timestamp.isoformat(),
                "final_decision": {
                    "action": trading_signal.final_action,
                    "confidence": trading_signal.final_confidence,
                    "signal_strength": trading_signal.signal_strength.value if hasattr(trading_signal.signal_strength, 'value') else str(trading_signal.signal_strength)
                },
                "analysis_breakdown": {
                    "kronos": {
                        "confidence": trading_signal.confidence_breakdown.get('kronos', 0),
                        "action": trading_signal.kronos_result.final_action if trading_signal.kronos_result else None,
                        "available": trading_signal.kronos_result is not None
                    },
                    "technical": {
                        "confidence": trading_signal.confidence_breakdown.get('technical', 0),
                        "action": trading_signal.technical_result.get('action') if trading_signal.technical_result else None,
                        "available": trading_signal.technical_result is not None
                    },
                    "ml": {
                        "confidence": trading_signal.confidence_breakdown.get('ml', 0),
                        "signal": trading_signal.ml_result.get('signal') if trading_signal.ml_result else None,
                        "available": trading_signal.ml_result is not None
                    }
                },
                "technical_indicators": trading_signal.technical_indicators,
                "key_factors": trading_signal.key_factors,
                "reasoning": trading_signal.reasoning,
                "entry_price": trading_signal.entry_price
            }
            
            # ÊµãËØïÊé®ÈÄÅÈÄöÁü•
            notification_sent = await core_trading_service.send_trading_signal_notification(trading_signal)
            result["notification_sent"] = notification_sent
            
            return result
            
        except Exception as e:
            logger.error(f"ÊµãËØïÂ¢ûÂº∫ÂàÜÊûêÂ§±Ë¥•: {e}")
            return {"status": "error", "message": str(e)}
    
    
    @app.post("/debug-funding-notification", summary="Ë∞ÉËØïË¥üË¥πÁéáÈÄöÁü•")
    async def debug_funding_notification():
        """Ë∞ÉËØïË¥üË¥πÁéáÈÄöÁü•Ê∂àÊÅØÊ†ºÂºè"""
        try:
            from app.services.negative_funding_monitor_service import NegativeFundingMonitorService
            
            funding_monitor = NegativeFundingMonitorService()
            
            # ÊâßË°å‰∏ÄÊ¨°ÁõëÊéßÊ£ÄÊü•
            result = await funding_monitor.run_monitoring_cycle(enable_enhanced_analysis=True)
            
            if result['success']:
                notification_message = result.get('notification_message', '')
                opportunities = result.get('opportunities', [])
                
                return {
                    "status": "success",
                    "message_length": len(notification_message),
                    "opportunities_count": len(opportunities),
                    "notification_message": notification_message,
                    "first_100_chars": notification_message[:100],
                    "last_100_chars": notification_message[-100:] if len(notification_message) > 100 else notification_message,
                    "opportunities_summary": [
                        {
                            "symbol": opp.get('symbol_name', ''),
                            "rate": opp.get('funding_rate_percent', 0),
                            "score": opp.get('score', 0)
                        } for opp in opportunities[:3]
                    ]
                }
            else:
                return {
                    "status": "error",
                    "message": "ÁõëÊéßÊ£ÄÊü•Â§±Ë¥•",
                    "error": result.get('error', 'Êú™Áü•ÈîôËØØ')
                }
                
        except Exception as e:
            logger.error(f"Ë∞ÉËØïË¥üË¥πÁéáÈÄöÁü•Â§±Ë¥•: {e}")
            return {
                "status": "error", 
                "message": str(e),
                "traceback": str(e.__traceback__)
            }
    
    # TradingViewÊâ´ÊèèÂô®ÊµãËØïÁ´ØÁÇπ
    @app.post("/test-tradingview-scanner", summary="ÊµãËØïTradingViewÊâ´ÊèèÂô®")
    async def test_tradingview_scanner():
        """ÊµãËØïTradingViewÊâ´ÊèèÂô®ÂäüËÉΩ"""
        try:
            if hasattr(app.state, 'tradingview_scheduler_service'):
                scheduler_service = app.state.tradingview_scheduler_service
                logger.info("üß™ ÊâãÂä®ÊµãËØïTradingViewÊâ´ÊèèÂô®...")
                
                # ÊâßË°åÊâãÂä®Êâ´Êèè
                result = await scheduler_service.scan_and_notify()
                
                return {
                    "status": "success",
                    "message": f"TradingViewÊâ´ÊèèÂÆåÊàêÔºåÂèëÁé∞ {result.get('symbols_count', 0)} ‰∏™Âº∫ÂäøÂ∏ÅÁßç",
                    "data": {
                        "symbols_count": result.get('symbols_count', 0),
                        "symbols": result.get('symbols', []),
                        "notification_sent": result.get('notification_sent', False),
                        "execution_time": result.get('execution_time')
                    },
                    "timestamp": datetime.now().isoformat()
                }
            else:
                return {
                    "status": "error",
                    "message": "TradingViewË∞ÉÂ∫¶ÊúçÂä°Êú™ÂêØÂä®",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"ÊµãËØïTradingViewÊâ´ÊèèÂô®Â§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"ÊµãËØïÂ§±Ë¥•: {str(e)}")
    
    # TradingViewÊâ´ÊèèÂô®Áä∂ÊÄÅÊü•Áúã
    @app.get("/tradingview-scanner-status", summary="Êü•ÁúãTradingViewÊâ´ÊèèÂô®Áä∂ÊÄÅ")
    async def get_tradingview_scanner_status():
        """Ëé∑ÂèñTradingViewÊâ´ÊèèÂô®Áä∂ÊÄÅ‰ø°ÊÅØ"""
        try:
            if hasattr(app.state, 'tradingview_scheduler_service'):
                scheduler_service = app.state.tradingview_scheduler_service
                
                # Ëé∑ÂèñË∞ÉÂ∫¶Âô®Áä∂ÊÄÅ
                status = await scheduler_service.get_scheduler_status()
                
                # Ëé∑ÂèñÂÅ•Â∫∑Ê£ÄÊü•
                health = await scheduler_service.health_check()
                
                return {
                    "status": "success",
                    "scheduler_status": status,
                    "health_check": health,
                    "startup_scan_result": getattr(app.state, 'startup_tradingview_scan', None),
                    "timestamp": datetime.now().isoformat()
                }
            else:
                return {
                    "status": "error",
                    "message": "TradingViewË∞ÉÂ∫¶ÊúçÂä°Êú™ÂêØÂä®",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñTradingViewÊâ´ÊèèÂô®Áä∂ÊÄÅÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÁä∂ÊÄÅÂ§±Ë¥•: {str(e)}")

    # Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÁõ∏ÂÖ≥API
    @app.post("/api/core-symbols/push", summary="ÊâãÂä®Ëß¶ÂèëÊ†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ")
    async def manual_core_symbols_push():
        """ÊâãÂä®Ëß¶ÂèëÊ†∏ÂøÉÂ∏ÅÁßçÊìç‰ΩúÂª∫ËÆÆÊé®ÈÄÅ"""
        try:
            logger.info("üß™ ÊâãÂä®Ëß¶ÂèëÊ†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ...")
            
            # ÊâßË°åÊ†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ
            result = await perform_startup_core_symbols_push()
            
            if result["status"] == "success":
                return {
                    "status": "success",
                    "message": "Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂÆåÊàê",
                    "data": result,
                    "timestamp": datetime.now().isoformat()
                }
            else:
                return {
                    "status": "error",
                    "message": f"Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂ§±Ë¥•: {result.get('error', 'Êú™Áü•ÈîôËØØ')}",
                    "data": result,
                    "timestamp": datetime.now().isoformat()
                }
                
        except Exception as e:
            logger.error(f"ÊâãÂä®Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Êé®ÈÄÅÂ§±Ë¥•: {str(e)}")

    @app.get("/api/core-symbols/status", summary="Êü•ÁúãÊ†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÁä∂ÊÄÅ")
    async def get_core_symbols_status():
        """Ëé∑ÂèñÊ†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÁä∂ÊÄÅ‰ø°ÊÅØ"""
        try:
            # Ëé∑ÂèñÂêØÂä®Êé®ÈÄÅÁä∂ÊÄÅ
            startup_push_status = getattr(app.state, 'startup_core_symbols_push_results', {})
            
            # Ê£ÄÊü•Áªü‰∏ÄË∞ÉÂ∫¶Âô®Áä∂ÊÄÅ
            scheduler_running = hasattr(app.state, 'scheduler') and app.state.scheduler.is_running()
            
            return {
                "status": "success",
                "startup_push_completed": True,
                "startup_push_result": startup_push_status,
                "scheduler_running": scheduler_running,
                "integration_status": "Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÂ∑≤Êï¥ÂêàÂà∞Áªü‰∏ÄË∞ÉÂ∫¶Âô®",
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÊ†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅÁä∂ÊÄÅÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÁä∂ÊÄÅÂ§±Ë¥•: {str(e)}")

    @app.post("/api/core-symbols/scheduler/start", summary="ÂêØÂä®Ê†∏ÂøÉÂ∏ÅÁßçÂÆöÊó∂Êé®ÈÄÅ")
    async def start_core_symbols_scheduler():
        """ÂêØÂä®Ê†∏ÂøÉÂ∏ÅÁßçÂÆöÊó∂Êé®ÈÄÅË∞ÉÂ∫¶Âô®"""
        try:
            # Ê£ÄÊü•Áªü‰∏ÄË∞ÉÂ∫¶Âô®Áä∂ÊÄÅ
            if hasattr(app.state, 'scheduler') and app.state.scheduler.is_running():
                return {
                    "status": "success",
                    "message": "Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ‰ªªÂä°Â∑≤Âú®Áªü‰∏ÄË∞ÉÂ∫¶Âô®‰∏≠ËøêË°å",
                    "scheduler_info": {
                        "running": True,
                        "integration_status": "Â∑≤Êï¥ÂêàÂà∞Áªü‰∏ÄË∞ÉÂ∫¶Âô®"
                    },
                    "timestamp": datetime.now().isoformat()
                }
            else:
                return {
                    "status": "error",
                    "message": "Áªü‰∏ÄË∞ÉÂ∫¶Âô®Êú™ËøêË°å",
                    "timestamp": datetime.now().isoformat()
                }
            
        except Exception as e:
            logger.error(f"Ê£ÄÊü•Ê†∏ÂøÉÂ∏ÅÁßçË∞ÉÂ∫¶Âô®Áä∂ÊÄÅÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Ê£ÄÊü•Â§±Ë¥•: {str(e)}")

    @app.post("/api/core-symbols/scheduler/stop", summary="ÂÅúÊ≠¢Ê†∏ÂøÉÂ∏ÅÁßçÂÆöÊó∂Êé®ÈÄÅ")
    async def stop_core_symbols_scheduler():
        """ÂÅúÊ≠¢Ê†∏ÂøÉÂ∏ÅÁßçÂÆöÊó∂Êé®ÈÄÅË∞ÉÂ∫¶Âô®"""
        try:
            return {
                "status": "info",
                "message": "Ê†∏ÂøÉÂ∏ÅÁßçÊé®ÈÄÅ‰ªªÂä°Â∑≤Êï¥ÂêàÂà∞Áªü‰∏ÄË∞ÉÂ∫¶Âô®‰∏≠ÔºåÊó†Ê≥ïÂçïÁã¨ÂÅúÊ≠¢",
                "note": "Â¶ÇÈúÄÂÅúÊ≠¢ÔºåËØ∑ÂÅúÊ≠¢Êï¥‰∏™Â∫îÁî®Êàñ‰ΩøÁî®Áªü‰∏ÄË∞ÉÂ∫¶Âô®ÁÆ°ÁêÜÊé•Âè£",
                "timestamp": datetime.now().isoformat()
            }
                
        except Exception as e:
            logger.error(f"ÂÅúÊ≠¢Ê†∏ÂøÉÂ∏ÅÁßçË∞ÉÂ∫¶Âô®Â§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"ÂÅúÊ≠¢Â§±Ë¥•: {str(e)}")
    
    # ÁΩëÊ†º‰∫§ÊòìÁõ∏ÂÖ≥ÊµãËØïÁ´ØÁÇπ
    @app.post("/test-grid-trading", summary="ÊµãËØïÁΩëÊ†º‰∫§ÊòìÊé®Ëçê")
    async def test_grid_trading():
        """ÊâãÂä®ÊµãËØïÁΩëÊ†º‰∫§ÊòìÊú∫‰ºöÊé®Ëçê"""
        try:
            if hasattr(app.state, 'grid_scheduler_extension') and app.state.grid_scheduler_extension:
                grid_extension = app.state.grid_scheduler_extension
                logger.info("üß™ ÊâãÂä®ÊµãËØïÁΩëÊ†º‰∫§ÊòìÊé®Ëçê...")
                
                # ÊâßË°åÁΩëÊ†º‰∫§ÊòìÊé®Ëçê
                success = await grid_extension.run_startup_grid_recommendations()
                
                if success:
                    return {
                        "status": "success",
                        "message": "ÁΩëÊ†º‰∫§ÊòìÊé®ËçêÊµãËØïÂÆåÊàê",
                        "timestamp": datetime.now().isoformat()
                    }
                else:
                    return {
                        "status": "warning",
                        "message": "ÁΩëÊ†º‰∫§ÊòìÊé®ËçêÊµãËØïÂ§±Ë¥•",
                        "timestamp": datetime.now().isoformat()
                    }
            else:
                return {
                    "status": "error",
                    "message": "ÁΩëÊ†º‰∫§ÊòìË∞ÉÂ∫¶Âô®Êâ©Â±ïÊú™ÂàùÂßãÂåñ",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"ÊµãËØïÁΩëÊ†º‰∫§ÊòìÊé®ËçêÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"ÊµãËØïÂ§±Ë¥•: {str(e)}")
    
    @app.get("/grid-trading-status", summary="Êü•ÁúãÁΩëÊ†º‰∫§ÊòìÊé®ËçêÁä∂ÊÄÅ")
    async def get_grid_trading_status():
        """Ëé∑ÂèñÁΩëÊ†º‰∫§ÊòìÊé®ËçêÁä∂ÊÄÅ‰ø°ÊÅØ"""
        try:
            if hasattr(app.state, 'grid_scheduler_extension') and app.state.grid_scheduler_extension:
                grid_extension = app.state.grid_scheduler_extension
                
                return {
                    "status": "success",
                    "extension_initialized": True,
                    "startup_analysis_result": getattr(app.state, 'startup_grid_trading_analysis_results', None),
                    "message": "ÁΩëÊ†º‰∫§ÊòìË∞ÉÂ∫¶Âô®Êâ©Â±ïËøêË°åÊ≠£Â∏∏",
                    "timestamp": datetime.now().isoformat()
                }
            else:
                return {
                    "status": "error",
                    "extension_initialized": False,
                    "message": "ÁΩëÊ†º‰∫§ÊòìË∞ÉÂ∫¶Âô®Êâ©Â±ïÊú™ÂàùÂßãÂåñ",
                    "timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÁΩëÊ†º‰∫§ÊòìÁä∂ÊÄÅÂ§±Ë¥•: {e}")
            raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÁä∂ÊÄÅÂ§±Ë¥•: {str(e)}")
    
    return app

def main():
    """‰∏ªÂáΩÊï∞"""
    try:
        logger.info(f"üöÄ Starting server on {settings.host}:{settings.port}")
        logger.info(f"üìã Debug mode: {settings.debug}")
        logger.info(f"üìä Log level: {settings.log_level}")
        
        # ÂàõÂª∫Â∫îÁî®
        app = create_app()
        
        # ÂêØÂä®ÊúçÂä°Âô®
        if settings.debug:
            # ÂºÄÂèëÊ®°ÂºèÔºö‰ΩøÁî®importÂ≠óÁ¨¶‰∏≤‰ª•ÊîØÊåÅÁÉ≠ÈáçËΩΩ
            uvicorn.run(
                "main:create_app",
                host=settings.host,
                port=settings.port,
                log_level=settings.log_level.lower(),
                reload=True,
                access_log=True,
                factory=True
            )
        else:
            # Áîü‰∫ßÊ®°ÂºèÔºöÁõ¥Êé•‰º†ÈÄíappÂØπË±°
            uvicorn.run(
                app,
                host=settings.host,
                port=settings.port,
                log_level=settings.log_level.lower(),
                access_log=True
            )
        
    except KeyboardInterrupt:
        logger.info("üõë Server stopped by user")
    except Exception as e:
        logger.error(f"‚ùå Server startup failed: {e}")
        raise

if __name__ == "__main__":
    main()
